<!DOCTYPE HTML>
<html lang="zh-CN" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rainning in the utopia</title>
                <meta name="robots" content="noindex" />
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="favicon.svg">
                        <link rel="shortcut icon" href="favicon.png">
                <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
                <link rel="stylesheet" href="css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
                <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">概述</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">JavaScript</li><li class="chapter-item expanded "><div><strong aria-hidden="true">1.</strong> 基础</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="JavaScript/作用域和闭包.html"><strong aria-hidden="true">1.1.</strong> 作用域和闭包</a></li><li class="chapter-item expanded "><a href="JavaScript/JS变量.html"><strong aria-hidden="true">1.2.</strong> JS变量</a></li><li class="chapter-item expanded "><a href="JavaScript/防抖和节流.html"><strong aria-hidden="true">1.3.</strong> 防抖和节流</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.</strong> 进阶</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="JavaScript/函数相关（compose，pip，memoize，curry，偏函数）.html"><strong aria-hidden="true">2.1.</strong> 函数相关（compose，pip，memoize，curry，偏函数）</a></li><li class="chapter-item expanded "><a href="JavaScript/过滤重复请求-时间窗口.html"><strong aria-hidden="true">2.2.</strong> 过滤重复请求 - 时间窗口</a></li><li class="chapter-item expanded "><a href="JavaScript/不稳定网络环境下的指数补偿.html"><strong aria-hidden="true">2.3.</strong> 不稳定网络环境下的指数补偿</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.</strong> ES6</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="JavaScript/ES6中继承对static函数，箭头函数，普通函数的处理.html"><strong aria-hidden="true">3.1.</strong> ES6中的继承各种形式的函数处理</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">CSS</li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> 基础</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="CSS/居中布局.html"><strong aria-hidden="true">4.1.</strong> 居中布局的几种方式</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">React</li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> 虚拟DOM</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="React/虚拟DOM.html"><strong aria-hidden="true">5.1.</strong> 虚拟DOM</a></li><li class="chapter-item expanded "><a href="React/手动实现一个虚拟DOM.html"><strong aria-hidden="true">5.2.</strong> 手动实现一个虚拟DOM</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> React事件</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="React/React事件简单记录.html"><strong aria-hidden="true">6.1.</strong> 简单记录</a></li><li class="chapter-item expanded "><a href="React/React事件机制.html"><strong aria-hidden="true">6.2.</strong> React事件机制源码简单分析</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.</strong> Hooks</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="React/ReactHooks详解.html"><strong aria-hidden="true">7.1.</strong> React Hooks 详解</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Vue</li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.</strong> Vue</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="Vue/Vue2.x响应式原理简单解析.html"><strong aria-hidden="true">8.1.</strong> Vue2.x 响应式原理简单解析</a></li><li class="chapter-item expanded "><a href="Vue/异步更新队列.html"><strong aria-hidden="true">8.2.</strong> 异步更新队列</a></li><li class="chapter-item expanded "><a href="Vue/computed,watch,watchEffect.html"><strong aria-hidden="true">8.3.</strong> computed,watch,watchEffect</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.</strong> Vuex</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="Vue/Vuex简单源码.html"><strong aria-hidden="true">9.1.</strong> Vuex简单源码</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">网络</li><li class="chapter-item expanded "><div><strong aria-hidden="true">10.</strong> 网络基础</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">11.</strong> 扩展阅读</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="Network/HTTP2.0_&_HTTP3.0.html"><strong aria-hidden="true">11.1.</strong> HTTP2.0 &amp; HTTP3.0</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Git</li><li class="chapter-item expanded "><div><strong aria-hidden="true">12.</strong> 个人记录</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="Git/git代理.html"><strong aria-hidden="true">12.1.</strong> Git代理</a></li><li class="spacer"></li></ol></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">Rainning in the utopia</h1>

                    <div class="right-buttons">
                                                <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="概括"><a class="header" href="#概括">概括</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="作用域和闭包"><a class="header" href="#作用域和闭包">作用域和闭包</a></h1>
<h2 id="执行上下文"><a class="header" href="#执行上下文">执行上下文</a></h2>
<p>针对一段script标签或者一个函数而言</p>
<ul>
<li>
<p><code>JS</code>只有全局作用域和函数作用域（在 <code>es6</code> 之前）</p>
</li>
<li>
<p>使用 <code>var</code> 声明的变量会在执行之前提升到作用域的最顶端。</p>
</li>
<li>
<p>即可以在函数声明之前调用函数。在变量声明之前调用变量（此时变量的值为 <code>undefined</code> ）。</p>
</li>
<li>
<p>函数还包括this，arguments</p>
</li>
</ul>
<h2 id="this"><a class="header" href="#this">this</a></h2>
<p>只有在执行的时候才能确定。包括赋值引用。注意区分构造函数内部的 <code>this</code> 。</p>
<p>可以通过 <code>call</code>, <code>apply</code> , <code>bind</code> 来改变 <code>this</code> 的指向。</p>
<h2 id="闭包"><a class="header" href="#闭包">闭包</a></h2>
<p>返回一个函数或者传入一个函数去执行。都可以称之为闭包。</p>
<p>在这个闭包函数内部，可以定义变量来防止外部污染。即，私有变量。</p>
<p>不过需要注意内存泄露问题，因为在这边定义的变量无法自动释放。</p>
<pre><code class="language-js">function F1() {
  var a = 100;
  return function () {
    console.log(a); // 自由变量，取父级作用域中的值。
  };
}

var f1 = F1();
var a = 200;
f1(); // 100
</code></pre>
<h2 id="创建10个标签注入点击事件分别按顺序输出1-10"><a class="header" href="#创建10个标签注入点击事件分别按顺序输出1-10">创建10个标签，注入点击事件，分别按顺序输出1-10</a></h2>
<pre><code class="language-js">var i;

for (i = 0; i &lt; 10; i++) {
  (function (i) {
    var a = document.createElement(&quot;a&quot;);
    a.innerHTML = i + &quot;&lt;br&gt;&quot;;
    a.addEventListener(&quot;click&quot;, function (e) {
      e.preventDefault();
      alert(i);
    });
    document.body.appendChild(a);
  })(i);
}
</code></pre>
<p>新的es6可以用let来解决这个问题。</p>
<pre><code class="language-js">for (let i = 0; i &lt; 10; i++) {
  var a = document.createElement(&quot;a&quot;);
  a.innerHTML = i + &quot;&lt;br&gt;&quot;;
  a.addEventListener(&quot;click&quot;, function (e) {
    e.preventDefault();
    alert(i);
  });
  document.body.appendChild(a);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="js变量复习"><a class="header" href="#js变量复习">JS变量复习</a></h1>
<ul>
<li>typeof 能得到哪些类型</li>
<li>=== 和 ==</li>
<li>JS的内置函数</li>
<li>按存储方式划分，js变量有哪些类型</li>
<li>理解JSON</li>
</ul>
<h2 id="变量类型"><a class="header" href="#变量类型">变量类型</a></h2>
<h3 id="值类型和引用类型"><a class="header" href="#值类型和引用类型">值类型和引用类型</a></h3>
<p>值类型：undefined, number, boolean, string, symbol, null</p>
<p>引用类型：function, object</p>
<p>还牵扯到堆内存和栈内存的关系，稍微延伸一下。</p>
<h4 id="堆内存和栈内存"><a class="header" href="#堆内存和栈内存">堆内存和栈内存</a></h4>
<p><strong>栈内存</strong>主要用于存储各种<strong>基本类型的</strong>变量，包括boolean、number、string、undefined、null，以及对象变量的指针，这时候栈内存给人的感觉就像一个线性排列的空间，每个小单元大小基本相等。</p>
<p>而堆内存主要负责像对象Object这种变量类型的存储，如下图<img src="JavaScript/./images/JS%E5%8F%98%E9%87%8F%E5%A4%8D%E4%B9%A0-461976-20180823211511434-1707579794.png" alt="img" /></p>
<p>原始数据类型都有固定的大小保存在栈内存中，由系统自动分配存储空间，可以直接进行操作。</p>
<p>对于new出来的变量，思考一下new关键字所作所为，就知道，new出来的对象都是存储在堆内存中的。</p>
<p>我们常说的值类型和引用类型其实说的就是栈内存变量和堆内存变量，再想想值传递和引用传递、深拷贝和浅拷贝，都是围绕堆栈内存展开的，一个是处理值，一个是处理指针。</p>
<h4 id="变量定义的过程"><a class="header" href="#变量定义的过程">变量定义的过程</a></h4>
<p>例如<code>var a = 10</code>:</p>
<p>先将<code>10</code>压入栈中，然后在当前作用域中声明一个变量<code>a</code>，此时<code>a = undefined</code>，然后再将 <code>a</code> <strong>关联</strong>到<code>10</code>。</p>
<h4 id="函数定义的过程"><a class="header" href="#函数定义的过程">函数定义的过程</a></h4>
<p>现在堆内存中开辟一块空间，将函数的以字符串的形式存入。然后会有一个十六进制的堆内存的值。然后存入栈内存中。然后声明变量fn，然后将fn关联到这个内存地址上。</p>
<h4 id="垃圾回收机制"><a class="header" href="#垃圾回收机制">垃圾回收机制</a></h4>
<h5 id="浏览器的垃圾回收机制"><a class="header" href="#浏览器的垃圾回收机制">浏览器的垃圾回收机制</a></h5>
<ul>
<li>
<p>引用计数（RC）</p>
</li>
<li>
<p>标记清除</p>
<p>标记清除指的是当变量进入环境时，这个变量标记为“进入环境”;而当变量离开环境时，则将其标记为“离开环境”，最后，垃圾回收器完成内存清除工作，销毁并回收那些被标记为“离开环境”的值所占用的内存空间</p>
</li>
</ul>
<h5 id="v8的垃圾回收机制"><a class="header" href="#v8的垃圾回收机制">V8的垃圾回收机制</a></h5>
<p>分代回收：新生代和老生代。</p>
<h6 id="新生代的垃圾回收"><a class="header" href="#新生代的垃圾回收">新生代的垃圾回收</a></h6>
<p>在堆内存中分两个部分，一个 From（使用中的空间） ，一个
To（闲置状态），分配对象的时候先在from空间中进行分配，如果一个对象不再被引用了，那么将会被留在From中，将其他被引用的对象移动到To空间中，然后对调From和To，最后释放To中的空间。</p>
<h6 id="晋升"><a class="header" href="#晋升">晋升</a></h6>
<p>在新生代垃圾回收的过程中，当一个对象经过多次复制后依然存活，他将会被认为是生命周期较长的对象，随后会被移动到老生代中，采用新的算法进行管理</p>
<p>在From空间和To空间进行反转的过程中，如果To空间中的使用量已经超过了25%,那么就将From中的对象直接晋升到老生代内存空间中</p>
<h6 id="老生代的垃圾回收"><a class="header" href="#老生代的垃圾回收">老生代的垃圾回收</a></h6>
<p>老生代的内存空间是一个连续的结构。</p>
<p>标记清除（Mark Sweep）：标记要回收的对象，直接释放相应的地址空间。执行完成之后会导致内存不连续 。</p>
<p>标记合并（Mark Compact）：将存活的对象移动到一边，需要被回收的移动到另一边。然后对需要被回收的区域进行整体垃圾回收。</p>
<h3 id="typeof"><a class="header" href="#typeof">typeof</a></h3>
<p><img src="JavaScript/./images/JS%E5%8F%98%E9%87%8F%E5%A4%8D%E4%B9%A0-image-20210718123027904.png" alt="image-20210718123027904" /></p>
<h2 id="变量计算"><a class="header" href="#变量计算">变量计算</a></h2>
<h3 id="强制类型转换的场景"><a class="header" href="#强制类型转换的场景">强制类型转换的场景</a></h3>
<ul>
<li>字符串拼接</li>
<li>== 运算符</li>
<li>if语句</li>
<li>逻辑运算</li>
</ul>
<p><img src="JavaScript/./images/JS%E5%8F%98%E9%87%8F%E5%A4%8D%E4%B9%A0-image-20210718131419517.png" alt="image-20210718131419517" /></p>
<p><img src="JavaScript/./images/JS%E5%8F%98%E9%87%8F%E5%A4%8D%E4%B9%A0-image-20210718131523165.png" alt="image-20210718131523165" /></p>
<h4 id="双等号的比较的时候的类型转换"><a class="header" href="#双等号的比较的时候的类型转换">双等号的比较的时候的类型转换</a></h4>
<p><img src="JavaScript/./images/JS%E5%8F%98%E9%87%8F%E5%A4%8D%E4%B9%A0-image-20210718131629045.png" alt="image-20210718131629045" /></p>
<p><img src="JavaScript/./images/JS%E5%8F%98%E9%87%8F%E5%A4%8D%E4%B9%A0-image-20210718134441100.png" alt="image-20210718134441100" /></p>
<p><img src="JavaScript/./images/JS%E5%8F%98%E9%87%8F%E5%A4%8D%E4%B9%A0-image-20210718135241174.png" alt="image-20210718135241174" /></p>
<p><img src="JavaScript/./images/JS%E5%8F%98%E9%87%8F%E5%A4%8D%E4%B9%A0-image-20210718135354266.png" alt="image-20210718135354266" /></p>
<p><img src="JavaScript/./images/JS%E5%8F%98%E9%87%8F%E5%A4%8D%E4%B9%A0-image-20210718135544734.png" alt="image-20210718135544734" /></p>
<p><img src="JavaScript/./images/JS%E5%8F%98%E9%87%8F%E5%A4%8D%E4%B9%A0-image-20210718135613363.png" alt="image-20210718135613363" /></p>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-js">// 防抖。当持续触发事件时，一定时间段内没有再触发事件，事件处理函数才会执行一次，如果设定的时间到来之前，又一次触发了事件，就重新开始延时。
let deBounce = (fn, delay) =&gt; {
  let timer = null;
  return function (...args) {
    if (timer) {
      clearTimeout(timer);
    }
    timer = setTimeout(() =&gt; {
      fn(...args);
    }, delay)
  }
}

// 节流。当持续触发事件时，保证一定时间段内只调用一次事件处理函数。
let throttle = (fn, delay) =&gt; {
  let flag = true;
  return function (...args) {
    if (!flag) return;
    flag = false;
    setTimeout(() =&gt; {
      fn(...args)
      flag = true;
    }, delay)
  }
}

let deBounce2 = (fn, delay) =&gt; {
  let start = Date.now();
  return function (...args) {
    if (Date.now() - start &gt; delay) {
      fn(...args);
    }
    start = Date.now();
  }
}

let throttle2 = (fn, delay) =&gt; {
  let start = Date.now();
  return function (...args) {
    if (Date.now() - start &gt; delay) {
      fn(...args);
      start = Date.now();
    }
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="函数相关"><a class="header" href="#函数相关">函数相关</a></h1>
<h2 id="compose函数和pipe函数"><a class="header" href="#compose函数和pipe函数">compose函数和pipe函数</a></h2>
<p>函数组合，将多个函数组合在一起。</p>
<h3 id="compose函数"><a class="header" href="#compose函数">compose函数</a></h3>
<ul>
<li>将需要嵌套执行的函数平铺</li>
<li>嵌套执行指的是，一个函数的返回值作为另一个函数的参数</li>
</ul>
<p><code>compose</code> 函数主要是实现了函数式编程中的 <code>pointfree</code> ，使我们专注于转换而不是数据本身。</p>
<p>也就是说，我们可以把数据处理的过程，定义成一种与参数无关合成运算。不需要关注参数本身，只需要将运算合成即可。</p>
<p><code>pointfree</code> 就是不使用所要处理的值，只合成运算过程。即无参数分隔。</p>
<pre><code class="language-js">let compose = function () {
  // 将arguments转为数组
  let args = [].slice.call(arguments)
  return function (params) {
    // 自右向左，依次执行
    return args.reduceRight(function (res, cb) {
      return cb(res)
    }, params)
  }
}
</code></pre>
<p>es6版：</p>
<pre><code class="language-js">const compost = (...args) =&gt; params =&gt; args.reduceRight((res, cb) =&gt; cb(res), params)
</code></pre>
<p>Redux就是依赖compose来实现中间件的功能的。</p>
<p>Webpack的loader也是。</p>
<h3 id="pipe函数"><a class="header" href="#pipe函数">pipe函数</a></h3>
<p>pipe就是compose的复制版，只不过执行方向变了，改为从左向右</p>
<pre><code class="language-js">export default function Pipe(...funcs) {
  return params =&gt; funcs.reduce((res, cb) =&gt; cb(res), params)
}
</code></pre>
<h2 id="常用函数"><a class="header" href="#常用函数">常用函数</a></h2>
<h3 id="memozition"><a class="header" href="#memozition">memozition</a></h3>
<p>将上次的计算结果缓存起来，当下次调用时，如果遇到了相同的参数，就直接返回缓存中的数据</p>
<p>原理：</p>
<p>将参数和对应结果存储到一个对象中，调用时，先判断参数对应的数据是否存在，如果存在则直接返回，如果不存在才计算并存到缓存中。</p>
<p>闭包的灵魂体现！</p>
<p>lodash中的memoize实现：</p>
<pre><code class="language-js">// func是需要缓存的函数，resolver是计算key的函数
function memoize(func, resolver) {
  // 类型校验
  if (typeof func !== 'function' || (resolver != null &amp;&amp; typeof resolver !== 'function')) {
    throw new TypeError('Expected a function')
  }
  const memoized = function(...args) {
    // 先计算一下key，如果没有计算函数，则取第一个参数
    const key = resolver ? resolver.apply(this, args) : args[0]
    
    // 取缓存
    const cache = memoized.cache

    // 如果缓存中有值，则直接返回
    if (cache.has(key)) {
      return cache.get(key)
    }
    // 缓存中没有值，先计算，再放入缓存中，再更新缓存
    const result = func.apply(this, args)
    memoized.cache = cache.set(key, result) || cache
    return result
  }
  // 缓存初始化为Map
  memoized.cache = new (memoize.Cache || Map)
  // 返回缓存函数
  return memoized
}

memoize.Cache = Map

export default memoize
</code></pre>
<p>使用场景：</p>
<p>需要大量重复计算或依赖之前的结果的情况</p>
<p>比如斐波那契数列</p>
<h3 id="curry"><a class="header" href="#curry">curry</a></h3>
<p>将使用多个参数的一个函数，转化成一系列使用一个参数的函数的技术。</p>
<p><img src="JavaScript/./images/image-20210819164407867.png" alt="image-20210819164407867" /></p>
<p>比如，使用正则校验一个字符串：</p>
<p><img src="JavaScript/./images/image-20210819164453937.png" alt="image-20210819164453937" /></p>
<p>或者从对象数组中取某一个字符的值</p>
<p><img src="JavaScript/./images//image-20210819165020776.png" alt="image-20210819165020776" /></p>
<p>在调用 <code>getProp(&quot;age&quot;)</code> 之后，这个的返回值，就变成了接受一个对象并返回对象的 <code>age</code> 属性的函数，放在map中就很舒服了。</p>
<h3 id="偏函数"><a class="header" href="#偏函数">偏函数</a></h3>
<p>如果说，柯里化是将一个多参数函数转换成多个单参数函数，也就是将一个n元函数转换成n个一元函数。</p>
<p>那么偏函数就是固定一个函数的一个或者多个参数，也就是将一个n元函数转换成一个n-x元函数。</p>
<p>也就是：</p>
<pre><code class="language-js">柯里化： f(a,b,c) =&gt; f(a)(b)(c)
偏函数： f(a,b,c) =&gt; f(a,b)(c)
</code></pre>
<p>可以简单实用bind来实现</p>
<pre><code class="language-js">let add = (x, y) =&gt; x + y;
let rst = add.bind(null, 1);
rst(2); // 3
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="时间窗口"><a class="header" href="#时间窗口">时间窗口</a></h1>
<p>在一定时间内，如果请求同一个url，则只请求一次。</p>
<pre><code class="language-javascript">const fetch = require(&quot;node-fetch&quot;);

function hash(...args) {
  return args.join(&quot;,&quot;);
}

function window_request(f, time = 50) {
  let w = {};
  // 是否有时间窗口
  let flag = false;

  return (...args) =&gt; {
    return new Promise((resolve) =&gt; {
      // 如果w中没有这次请求（通过hash存入）, 如果有，则在最后 L54 将resolve存入到对应的resolvers里
      if (!w[hash(args)]) {
        w[hash(args)] = {
          func: f,
          args,
          // 将不同的request的resolve也添加进来，方便最后统一做处理。
          resolvers: [],
        };
      }

      // 如果没有时间窗口
      if (!flag) {
        // 接下来是创建一个时间窗口
        console.log('create a window')
        flag = true;
        setTimeout(() =&gt; {
          // 对w中每一个请求进行处理。
          Object.keys(w).forEach((key) =&gt; {
            // 获取参数进行执行
            const { func, args, resolvers } = w[key];
            console.log(&quot;run once ---- &quot;, resolvers.length);
            func(...args)
              .then((res) =&gt; {
                return res.text();
              })
              .then((t) =&gt; {
                // 将获取到的结果批量放到resolve中处理
                resolvers.forEach((r) =&gt; {
                  console.log(&quot;result anywhere&quot;);
                  r(t);
                });
                // 重置访问窗口
                flag = false;
                w = {};
              });
          });
        }, time);
      }

      w[hash(args)].resolvers.push(resolve);
    });
  };
}

const request = window_request(fetch, 20);

request(&quot;https://www.baidu.com&quot;);
request(&quot;https://www.baidu.com&quot;);
request(&quot;https://www.baidu.com&quot;);
request(&quot;https://www.baidu.com&quot;);
request(&quot;https://www.baidu.com&quot;);
request(&quot;https://www.baidu.com&quot;);
request(&quot;https://www.baidu.com&quot;);
console.log('break')
setTimeout(() =&gt; {
  request(&quot;https://www.baidu.com&quot;);
  request(&quot;https://www.baidu.com&quot;);
  request(&quot;https://www.baidu.com&quot;);
  request(&quot;https://www.baidu.com&quot;);
  request(&quot;https://www.baidu.com&quot;);
  request(&quot;https://www.baidu.com&quot;);
  request(&quot;https://www.baidu.com&quot;);
}, 10000);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="指数补偿"><a class="header" href="#指数补偿">指数补偿</a></h1>
<h2 id="在网络环境不稳定的情况下以指数级别的时间间隔发送请求直到任意某一次请求得到了返回"><a class="header" href="#在网络环境不稳定的情况下以指数级别的时间间隔发送请求直到任意某一次请求得到了返回">在网络环境不稳定的情况下，以指数级别的时间间隔发送请求，直到任意某一次请求得到了返回</a></h2>
<pre><code class="language-javascript">function request(url) {
  // 判断是否已经完成请求
  let resolved = false;
  // 次数
  let t = 1;

  return new Promise((resolve, reject) =&gt; {
    function doFetch() {
      // 如果已经完成请求，或者次数已达上限，则直接返回
      if (resolved || t &gt; 16) {
        return;
      }
      // 否则发送请求
      fetch(url).then((resp) =&gt; {
        // 如果标记还处在未完成的状态
        if (!resolved) {
          // 将结果返回
          resolve(resp);
          // 将标记置为已完成
          resolved = true;
        }
      });
      // 指数级的时间间隔发送请求
      setTimeout(() =&gt; {
        // 调用自己
        doFetch();
        t *= 2;
      }, t * 100);
    }

    // 首次调用
    doFetch();
  });
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="问题引入"><a class="header" href="#问题引入">问题引入</a></h1>
<p>最近一直在看原型继承相关的东西，翻到这么一篇文章：
<a href="http://wulv.site/2017-05-29/%E4%BB%8EES6%E4%B8%AD%E7%9A%84extends%E8%AE%B2js%E5%8E%9F%E5%9E%8B%E9%93%BE%E4%B8%8E%E7%BB%A7%E6%89%BF.html">从ES6中的extends讲js原型链与继承</a></p>
<p>文中有一个点让我很感兴趣，箭头函数在继承过程中无法通过super关键字获取，这是为什么呢？</p>
<h1 id="前置知识"><a class="header" href="#前置知识">前置知识</a></h1>
<h2 id="mdn上关于super的介绍"><a class="header" href="#mdn上关于super的介绍">MDN上关于super的介绍</a></h2>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/super">The super keyword is used to access and call functions on an object's parent - in
MDN</a> 大概有这么几个关键点：</p>
<ol>
<li>子类中存在constructor方法的时候，需要调用super方法，并且需要在使用this关键字之前调用</li>
<li>super关键字可以用来调用父对象上的方法</li>
<li>可以使用super来调用父对象上的静态方法</li>
<li>不可以使用delete来删除super上的属性</li>
<li>不可以复写super对象上的只读属性</li>
</ol>
<h2 id="子类中是否必须主动调用super方法"><a class="header" href="#子类中是否必须主动调用super方法">子类中是否必须主动调用super方法？</a></h2>
<p>我的看法是不需要。 网上有些文章（<a href="https://segmentfault.com/a/1190000008165717">比如这篇</a>）写道：</p>
<blockquote>
<p>因为若不执行super，则this无法初始化。</p>
</blockquote>
<p>我的个人理解是，this是指代执行上下文环境的，不存在无法初始化的情况。更准确的说法是这样：如果不使用super方法，那么父类中的属性值无法进行初始化，如果这个时候子类通过this字段来访问了父类中的属性值，那么只能得到一个undefined。至于为什么这么写编译的时候会报错？我的理解是，这应该是一种语法错误，而且是一种规范要求，ES6语法的规范要求，这种要求并不是说会影响到代码的实际执行。举个栗子：</p>
<pre><code>// typescript中一段简单的继承代码实现
class Parent {
    name = 'parent';
    func = function() {
        console.log('func in parent called.');
    }
}

class Child extends Parent {
    age = 3;
    func = function() {
        console.log('age is: ', this.age);    // 使用了this，不会报错
    }
}
</code></pre>
<p>这段代码非常简单，在子类中使用了this关键字，编译时不会报错，也可以正常执行。然后我们进行一点修改，在子类中引入constructor方法</p>
<pre><code>class Child extends Parent {
    age = 3;
    // error TS2377: Constructors for derived classes must contain a 'super' call.
    constructor() {
    
    }
    func = function() {
        console.log('age is: ', this.age);
    }
}
</code></pre>
<p>可以看到，编译阶段已经开始报错了。在typescript的语法中，子类的constructor方法中不但需要调用super方法，而且必须在第一行代码就调用super，否则都是会报错的。看下面这段代码:</p>
<pre><code>class Child extends Parent {
    age = 3;
    constructor() {
        console.log('First line in constructor without super method');
        super();    // error TS2376: A 'super' call must be the first statement in the constructor when a class contains initialized properties or has parameter properties.
    }
    func = function() {
        console.log('age is: ', this.age);
    }
}
</code></pre>
<p>来，我们接着改</p>
<pre><code>class Parent {
    name = 'parent';
    func = function() {
        console.log('func in parent called.');
    }
}

class Child extends Parent {
    age = 3;
    constructor() {
        console.log('Show property of parent, name is: ', this.name);    // error TS17009: 'super' must be called before accessing 'this' in the constructor of a derived class.
        console.log('Show property of child, age is: ', this.age);        // error TS17009: 'super' must be called before accessing 'this' in the constructor of a derived class.
        super();    // error TS2376: A 'super' call must be the first statement in the constructor when a class contains initialized properties or has parameter properties.
        console.log('Show property of parent, name is: ', this.name);
        console.log('Show property of child, age is: ', this.age);
    }
    func = function() {
        console.log('age is: ', this.age);
    }
}
</code></pre>
<p>可以看到，编译期已经开始报各种错误了，不过这不重要，我们这里利用typescript的编译器（tsc）来进行编译，并查看编译后的代码内容：</p>
<pre><code>var __extends = (this &amp;&amp; this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array &amp;&amp; function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var Parent = (function () {
    function Parent() {
        this.name = 'parent';
        this.func = function () {
            console.log('func in parent called.');
        };
    }
    return Parent;
}());
var Child = (function (_super) {
    __extends(Child, _super);
    function Child() {
        var _this = this;
        _this.age = 3;
        _this.func = function () {
            console.log('age is: ', this.age);
        };
        console.log('Show property of parent, name is: ', _this.name); // 输出undefined，因为此时子类的实例上还没有继承到父类的属性值
        console.log('Show property of child, age is: ', _this.age); // 输出3，子类实例自己的属性值可以访问
        _this = _super.call(this) || this; // 构造函数式的继承实现，这一步就是讲父类的属性值设置到子类实例上
        console.log('Show property of parent, name is: ', _this.name); // 输出parent，此时子类的实例上经过上一步的继承，得到了父类的属性值
        console.log('Show property of child, age is: ', _this.age);  // 输出3，子类实例自己的属性值可以访问
        return _this;
    }
    return Child;
}(Parent));
//# sourceMappingURL=demo.js.map
</code></pre>
<p>由此可以知道，在ES6中使用extends进行继承操作的过程中，</p>
<ul>
<li>子类并非必须调用super方法，除非存在constructor方法</li>
<li>在constructor方法中应该首先调用super方法，这是语法要求，不过这不是必须的</li>
<li>在调用super方法之前，将无法通过this关键字来访问父类的属性（这里就可以解释其他文章中提到的
‘若不执行super，则this无法初始化’，更准确的说法应该是‘若不执行super，则无法将父类的属性值初始化到当前子类实例上’）</li>
</ul>
<h2 id="子类中使用superprop和superexpr的方式是如何访问父类的属性和方法"><a class="header" href="#子类中使用superprop和superexpr的方式是如何访问父类的属性和方法">子类中使用super.prop和super[expr]的方式是如何访问父类的属性和方法？</a></h2>
<p>我们直接来看代码吧,关键点都注释了的</p>
<pre><code>class Parent {
    public name = 'parent';
    public static staticName = 'staticParent';
    public static staticFunc() {
        console.log('staticFunc called in parent.');
    }

    public arrowFunc = () =&gt; {
        console.log('arrowFunc called in parent.');
    }

    public normalFunc() {
        console.log('normalFunc called in parent.')
    }
}

class Child extends Parent {
    public static staticFunc() {
        super.staticFunc();
        console.log('staticFunc called in Child.');
    }

    arrowFunc = () =&gt; {
        super.arrowFunc();
        console.log('arrowFunc called in Child.');
    }

    normalFunc() {
        super.normalFunc();
        console.log('normalFunc called in Child.')
    }

    getName() {
        console.log('parent name is: ', super.name);
        console.log('parent staticName is: ', super.staticName);
        console.log('child name is: ', this.name);
    }
}

/** 编译后的代码 **/
var __extends = (this &amp;&amp; this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array &amp;&amp; function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var Parent = (function () {
    function Parent() {
        this.name = 'parent';
        this.arrowFunc = function () {
            console.log('arrowFunc called in parent.');
        };
    }
    // 编译后的静态方法可以存在于Parent类的内部
    Parent.staticFunc = function () {
        console.log('staticFunc called in parent.');
    };
    Parent.prototype.normalFunc = function () {
        console.log('normalFunc called in parent.');
    };
    return Parent;
}());
Parent.staticName = 'staticParent'; // 编译后的静态属性依然存在于Parent类外
var Child = (function (_super) {
    __extends(Child, _super);
    function Child() {
        var _this = _super !== null &amp;&amp; _super.apply(this, arguments) || this;
        _this.arrowFunc = function () { // 子类实例调用arrowFunc的时候会报错，因为_super.prototype上是不存在arrowFunc方法的
            _super.prototype.arrowFunc.call(_this); // Uncaught TypeError: Cannot read property 'call' of undefined
            console.log('arrowFunc called in Child.');
        };
        return _this;
    }
    Child.staticFunc = function () {
        _super.staticFunc.call(this);   // super可以正常访问父类的静态方法
        console.log('staticFunc called in Child.');
    };
    Child.prototype.normalFunc = function () {
        _super.prototype.normalFunc.call(this);
        console.log('normalFunc called in Child.');
    };
    Child.prototype.getName = function () {
        console.log('parent name is: ', _super.prototype.name); // 输出undefined， 父类原型（_super.prototype）上不存在name属性
        console.log('parent staticName is: ', _super.prototype.staticName); // 输出undefined，super无法正常访问父类的静态属性
        console.log('child name is: ', this.name);  // 输出parent，这是子类实例上的属性，继承自父类
    };
    return Child;
}(Parent));
//# sourceMappingURL=demo.js.map
</code></pre>
<p>这里再顺嘴提一句，关于静态属性和静态方法的区别。为什么在子类中通过super关键字来获取父类的静态方法经过编译后是_super.staticFunc，而获取静态属性依然是_super.prototype.staticName，从原型上获取导致获取失败呢？这个问题目前我还没有找到答案，希望有知道的小伙伴可以不吝指教。
不过我倒是搜到一些其他相关内容。 <a href="http://es6.ruanyifeng.com/#docs/class">Class 的静态属性和实例属性</a></p>
<blockquote>
<p>因为 ES6 明确规定，Class 内部只有静态方法，没有静态属性。</p>
</blockquote>
<p>虽然这种规定从ES7开始得到了修正，我们目前已经可以将静态属性写在Class的内部，但是经过编译之后可以发现，静态属性依然存在于类的实现的外部。</p>
<pre><code>var Parent = (function () {
    function Parent() {
        this.name = 'parent';
        this.arrowFunc = function () {
            console.log('arrowFunc called in parent.');
        };
    }
    // 编译后的静态方法可以存在于Parent类的内部
    Parent.staticFunc = function () {
        console.log('staticFunc called in parent.');
    };
    Parent.prototype.normalFunc = function () {
        console.log('normalFunc called in parent.');
    };
    return Parent;
}());
Parent.staticName = 'staticParent'; // 编译后的静态属性依然存在于Parent类外
</code></pre>
<h1 id="回到问题本身"><a class="header" href="#回到问题本身">回到问题本身</a></h1>
<p>问：箭头函数在继承过程中无法通过super关键字获取，这是为什么呢？ 答：因为子类中使用super.prop和super[expr]的方式获取的是父类原型（prototype）上的方法，静态方法除外。</p>
<h1 id="参考资料"><a class="header" href="#参考资料">参考资料</a></h1>
<p><a href="http://wulv.site/2017-05-29/%E4%BB%8EES6%E4%B8%AD%E7%9A%84extends%E8%AE%B2js%E5%8E%9F%E5%9E%8B%E9%93%BE%E4%B8%8E%E7%BB%A7%E6%89%BF.html">从ES6中的extends讲js原型链与继承</a>
<a href="https://segmentfault.com/a/1190000008165717">React ES6 class constructor super()</a>
<a href="http://es6.ruanyifeng.com/#docs/class">Class 的静态属性和实例属性</a></p>
<p><a href="https://blog.csdn.net/qq_32442967/article/details/100086200?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-2.not_use_machine_learn_pai&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-2.not_use_machine_learn_pai">备份自</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="居中布局"><a class="header" href="#居中布局">居中布局</a></h1>
<h2 id="水平居中"><a class="header" href="#水平居中">水平居中</a></h2>
<h3 id="inline-block--text-align"><a class="header" href="#inline-block--text-align">inline-block + text-align</a></h3>
<pre><code class="language-css">.parent {
  text-align: center;
}

.children {
  display: inline-block;
}
</code></pre>
<p><code>text-align</code>会对<code>inline</code>级别的元素生效</p>
<h3 id="table--margin"><a class="header" href="#table--margin">table + margin</a></h3>
<pre><code class="language-css">.children {
  display: table;
  margin: 0 auto;
}
</code></pre>
<p>子元素display: table， table在没有设置宽度的时候，跟里面的内容的宽度是一样的。</p>
<p>table还可以使用margin: auto，因此可以实现水平居中。</p>
<h3 id="absolute--transform"><a class="header" href="#absolute--transform">absolute + transform</a></h3>
<pre><code class="language-css">.parent {
  position: relative;
}

.children {
  position: absolute;
  left: 50%;
  transform: translateX(-50%);
}
</code></pre>
<h3 id="flex--justify--content"><a class="header" href="#flex--justify--content">flex + justify + content</a></h3>
<pre><code class="language-css">.parent {
  display: flex;
  justify-content: center;
}
</code></pre>
<p>flex-item的默认样式是1</p>
<p>或</p>
<pre><code class="language-css">.parent {
  display: flex;
}

.children {
  margin: 0 auto;
}
</code></pre>
<h2 id="垂直居中"><a class="header" href="#垂直居中">垂直居中</a></h2>
<h3 id="tabel-cell--vertical-align"><a class="header" href="#tabel-cell--vertical-align">tabel-cell + vertical-align</a></h3>
<pre><code class="language-css">.parent {
  display: table-cell;
  vertical-align: middle;
}
</code></pre>
<p>tabel-cell会把子元素放在垂直中间，</p>
<p>vertical-align: middle再把内容居中</p>
<h3 id="absolute--transform-1"><a class="header" href="#absolute--transform-1">absolute + transform</a></h3>
<pre><code class="language-css">.parent {
  position: relative;
}

.children {
  position: absolute;
  top: 50%;
  transform: translateY(-50%);
}
</code></pre>
<h3 id="flex--align-items"><a class="header" href="#flex--align-items">flex + align-items</a></h3>
<pre><code class="language-css">.parent {
  display: flex;
  align-items: center;
}
</code></pre>
<h2 id="居中"><a class="header" href="#居中">居中</a></h2>
<h3 id="inline-block--text-align--tabel-cell--vertical-align"><a class="header" href="#inline-block--text-align--tabel-cell--vertical-align">inline-block + text-align + tabel-cell + vertical-align</a></h3>
<pre><code class="language-css">.parent {
  text-align: center;
  display: table-cell;
  vertical-align: middle;
}

.children {
  display: inline-block;
}
</code></pre>
<h3 id="absolute--transform-2"><a class="header" href="#absolute--transform-2">absolute + transform</a></h3>
<pre><code class="language-css">.parent {
  position: relative;
}

.children {
  position: absolute;
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
}
</code></pre>
<h3 id="flex--justify-content--align-items"><a class="header" href="#flex--justify-content--align-items">flex + justify-content + align-items</a></h3>
<pre><code class="language-css">.parent {
  display: flex;
  justify-content: center;
  align-items: center;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="虚拟dom"><a class="header" href="#虚拟dom">虚拟DOM</a></h1>
<h2 id="虚拟dom是什么"><a class="header" href="#虚拟dom是什么">虚拟DOM是什么</a></h2>
<p><a href="https://www.runoob.com/htmldom/htmldom-tutorial.html">首先了解一下DOM是什么</a>:</p>
<blockquote>
<p>DOM (Document Object Model) 译为文档对象模型，是 HTML 和 XML 文档的编程接口。<br />
HTML DOM 定义了访问和操作 HTML 文档的标准方法。<br />
DOM 以树结构表达 HTML 文档。</p>
</blockquote>
<p>然后我们来做一个小实验：</p>
<pre><code class="language-js">const div = document.createElement('div');
let str = '';
for(let i in div) {
  str += `${i} `
}
const attrs = str.split(' ')
console.log(attrs.splice(0,5), attrs.length)
</code></pre>
<p>out</p>
<pre><code class="language-js">(5) [&quot;align&quot;, &quot;title&quot;, &quot;lang&quot;, &quot;translate&quot;, &quot;dir&quot;] 294
</code></pre>
<p>我们可以看到浏览器对 <code>DOM</code> 赋予了很多属性来实现页面的各种功能，整个 <code>DOM</code> 的设计是相当复杂的。</p>
<p>当我们使用 <code>document.body.appendChild(node)</code> 往 <code>body</code> 节点上添加一个元素，调用该 <code>API</code> 之后会引发一系列的连锁反应。<br />
首先渲染引擎会将 <code>node</code> 节点添加到 <code>body</code> 节点之上，然后触发样式计算、布局、绘制、栅格化、合成等任务，我们把这一过程称为重排。<br />
除了重排之外，还有可能引起重绘或者合成操作，形象地理解就是“牵一发而动全身”。<br />
另外，对于 <code>DOM</code> 的不当操作还有可能引发强制同步布局和布局抖动的问题，这些操作都会大大降低渲染效率。<br />
因此，对于 <code>DOM</code> 的操作我们时刻都需要非常小心谨慎。</p>
<p>当然，对于简单的页面来说，其 <code>DOM</code> 结构还是比较简单的，所以以上这些操作 <code>DOM</code> 的问题并不会对用户体验产生太多影响。<br />
但是对于一些复杂的页面或者目前使用非常多的单页应用来说，其 <code>DOM</code> 结构是非常复杂的，而且还需要不断地去修改 <code>DOM</code> 树，每次操作 <code>DOM</code> 渲染
引擎都需要进行重排、重绘或者合成等操作，因为 <code>DOM</code> 结构复杂，所生成的页面结构也会很复杂，对于这些复杂的页面，执行一次重排或者重绘操作 都是非常耗时的，这就给我们带来了真正的性能问题。</p>
<p>所以我们需要有一种方式来减少 JavaScript 对 <code>DOM</code> 的操作，这时候虚拟 <code>DOM</code> 就上场了。</p>
<p>简而言之，我们需要用一种方式去描述浏览器的 <code>DOM</code> 结构，并且在数据更新的过程中通过虚拟 <code>DOM</code> 的对比来做一层“缓冲”。避免频繁的直接操作 <code>DOM</code> 对象。</p>
<h2 id="什么是虚拟dom"><a class="header" href="#什么是虚拟dom">什么是虚拟<code>DOM</code></a></h2>
<p>在谈论什么是虚拟 <code>DOM</code> 之前，我们先来看看虚拟 <code>DOM</code> 到底要解决哪些事情。</p>
<ul>
<li>将页面改变的内容应用到虚拟 <code>DOM</code> 上，而不是直接应用到 <code>DOM</code> 上。</li>
<li>变化被应用到虚拟 <code>DOM</code> 上时，虚拟 <code>DOM</code> 并不急着去渲染页面，而仅仅是调整虚拟 <code>DOM</code> 的内部状态，这样操作虚拟 <code>DOM</code> 的代价就变得非常轻了。</li>
<li>在虚拟 <code>DOM</code> 收集到足够的改变时，再把这些变化一次性应用到真实的 <code>DOM</code> 上。</li>
</ul>
<p>基于以上三点，我们再来看看什么是虚拟 DOM。为了直观理解，你可以参考下图：</p>
<p><img src="React/./images/%E8%99%9A%E6%8B%9Fdom%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="虚拟dom示意图.png" /></p>
<p>该图结合 React 流程画的一张虚拟 <code>DOM</code> 执行流程图，下面我们就结合这张图来分析下虚拟 <code>DOM</code> 到底怎么运行的。</p>
<p>创建阶段。首先依据 JSX 和基础数据创建出来虚拟 DOM，它反映了真实的 <code>DOM</code> 树的结构。然后由虚拟 <code>DOM</code> 树创建出真实 <code>DOM</code> 树，真实的 <code>DOM</code> 树生成完后，
再触发渲染流水线往屏幕输出页面。</p>
<p>更新阶段。如果数据发生了改变，那么就需要根据新的数据创建一个新的虚拟 <code>DOM</code> 树；然后 React 比较两个树，找出变化的地方，并把变化的地方一次性更新到真实的 <code>DOM</code> 树上</p>
<p>最后渲染引擎更新渲染流水线，并生成新的页面。</p>
<p>通过上面的描述，我们知道，当我们使用一个JS对象来描述浏览器的 <code>DOM</code> 结构的时候，这个对象就叫做虚拟 <code>DOM</code>。（浏览器的 <code>DOM</code> 对象过于复杂）</p>
<p>下面这段话是我摘录的一段对于虚拟 <code>DOM</code>的描述。</p>
<blockquote>
<ol>
<li><code>Virtual DOM</code> 是一种编程概念。在这个概念里， <code>UI</code> 以一种理想化的，或者说“虚拟的”表现形式被保存于内存中，并通过如 <code>ReactDOM</code> 等类库使之与“真实的”
<code>DOM</code> 同步。这一过程叫做协调。</li>
<li>这种方式赋予了 <code>React</code> 声明式的 <code>API</code>：你告诉 <code>React</code> 希望让 <code>UI</code> 是什么状态，<code>React</code> 就确保 <code>DOM</code> 匹配该状态。这使您可以从属性操作、
事件处理和手动 <code>DOM</code> 更新这些在构建应用程序时必要的操作中解放出来。</li>
<li>与其将 <code>Virtual DOM</code> 视为一种技术，不如说它是一种模式，人们提到它时经常是要表达不同的东西。在 <code>React</code> 的世界里，术语 <code>Virtual DOM</code> 通常 与
<code>React</code> 元素关联在一起，因为它们都是代表了用户界面的对象。</li>
<li>而 <code>React</code> 也使用一个名为 <code>fibers</code> 的内部对象来存放组件树的附加信息。上述二者也被认为是 <code>React</code> 中 <code>Virtual DOM</code> 实现的一部分。</li>
</ol>
</blockquote>
<p>我们来总结一下上面的话中比较重要的两点：</p>
<ol>
<li>虚拟 <code>DOM</code> 和真实 <code>DOM</code> 的交互不由虚拟 <code>DOM</code> 直接完成，交由第三方库完成，虚拟 <code>DOM</code> 只描述 <code>UI</code>，<code>UI</code> 到具体的展现，由 <code>ReactDOM</code>
等类库实现真正的渲染。 因此，<code>ReactNative</code>，小程序等跨端开发才得以实现。</li>
<li><code>React</code> 之类的类库，替你摆脱了频繁书写 <code>DOM</code> 操作的指令的坑，你不必再去书写类似 <code>document.getElementById(xxx).appendChild(xxx)</code>
之类的代码。 他们来负责数据变动到视图变动的过程。</li>
</ol>
<p>在 <code>React</code> 或者 <code>Vue</code> 中，虚拟 <code>DOM</code> 的创建都是由模板或者 <code>JSX</code> 来完成的，但是这两者到虚拟 <code>DOM</code> 的转移都是工程化干的事情（<code>webpack</code> +
<code>loader</code>），因此我们也不需要去书写类似 <code>React.createElement(xxx)</code> 的代码，只需要书写 <code>JSX</code> 即可以通过工程化自动生成上面的代码。</p>
<p>因此虚拟 <code>DOM</code> 极大程度上帮我们减轻了开发的负担，易于维护，并且不依赖于某一特定的环境。</p>
<h2 id="vdom的优点"><a class="header" href="#vdom的优点">VDOM的优点</a></h2>
<ul>
<li>
<p>抽象了原本的渲染过程，实现了跨平台的的能力，从而不局限于浏览器的 <code>DOM</code>，也可以是安卓和 <code>IOS</code> 的原生组件，也可以是小程序。</p>
</li>
<li>
<p>抽象了渲染过程之后，使得组件的抽象能力也得到了提升，并且可以适配 <code>DOM</code> 以外的渲染目标。</p>
</li>
<li>
<p><code>VDOM</code> 在牺牲了部分性能的前提下，增加了可维护性，这也是很多框架的通性。 实现了对 <code>DOM</code> 集中化操作，在数据改变的时候先对 <code>VDOM</code>
进行修改，再反映到真实的DOM中，用最小的代价来更新 <code>DOM</code> ，提升效率。</p>
</li>
<li>
<p>打开了函数式 <code>UI</code> 编程的大门</p>
</li>
<li>
<p>跨平台（ <code>ReactNative</code> ，<code>React VR</code> 等）</p>
</li>
<li>
<p>可以更好的实现 <code>SSR</code>，同构渲染等</p>
</li>
<li>
<p>组件的高度抽象化</p>
</li>
</ul>
<h2 id="vdom的缺点"><a class="header" href="#vdom的缺点">VDOM的缺点</a></h2>
<ul>
<li>首次渲染大量 <code>DOM</code> 的时候，由于多了一层虚拟 <code>DOM</code> 的计算，所以会比 <code>innerHTML</code> 插入的慢。</li>
<li>需要在内存中维护一份 <code>VDOM</code></li>
<li>如果虚拟 <code>DOM</code> 有着大量的更改，使用虚拟 <code>DOM</code> 是很合适的，如果是单一的频繁的更新的话，虚拟 <code>DOM</code> 需要花时间去处理计算工作。<br />
因此如果你有一个 <code>DOM</code> 节点相对较少的页面，使用 <code>VDOM</code> 可能会变慢。<br />
但是对于大多数单页面应用，使用 <code>VDOM</code> 应该是更快的</li>
</ul>
<h2 id="react-中的-diff-算法"><a class="header" href="#react-中的-diff-算法">React 中的 diff 算法</a></h2>
<p><a href="https://blog.csdn.net/qq_36407875/article/details/84965311">React的虚拟DOM与diff算法的理解</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/34363711">React源码分析 - Diff算法</a></p>
<h2 id="关于react中的虚拟dom"><a class="header" href="#关于react中的虚拟dom">关于React中的虚拟DOM</a></h2>
<p><a href="https://zhuanlan.zhihu.com/p/50218605">React中的虚拟DOM</a></p>
<blockquote>
<p><code>Fiber</code> 架构之后的不同。可以自行搜索 <code>Fiber</code> 相关的内容。<br />
<code>Fiber</code> 之后，虚拟 <code>DOM</code> 从树形结构变为了可恢复的链表的结构。</p>
</blockquote>
<p><code>Fiber</code> 的出现主要是为了解决在大量 <code>dom diff</code> 的过程中，保证渲染流畅，（原来的 <code>stack reconciler</code> 会在 <code>diff</code>
过程中阻塞线程，导致页面卡顿，因为只有<code>diff</code> 完成之后才会渲染页面）<br />
其实协程的另外一个称呼就是 <code>Fiber</code>，所以在这里我们可以把 <code>Fiber</code> 和协程关联起来，那么所谓的 <code>Fiber reconciler</code> 相信你也很清楚了，就是在执行算法的过程中出让主线程</p>
<p>这样就解决了 <code>Stack reconciler</code> 函数占用时间过久的问题。<br />
实际上的思想类似于时间切片的概念。<br />
主要利用了浏览器 <code>requestIdleCallback</code> 这个 <code>API</code></p>
<h2 id="关于vue中的虚拟dom"><a class="header" href="#关于vue中的虚拟dom">关于Vue中的虚拟DOM</a></h2>
<p>整体的实现思路大致类似上面的手动实现的方法。</p>
<p>以 <code>Vue2.x</code> 为例，可以在源码中找到<a href="https://github.com/vuejs/vue/blob/dev/src/core/vdom/patch.js">这个文件</a>来看一下。</p>
<p>在 <code>Vue3.x</code> 中并没有引进 <code>Fiber</code> 这一架构，具体原因可以在拓展阅读中查看。</p>
<h2 id="拓展阅读"><a class="header" href="#拓展阅读">拓展阅读</a></h2>
<ol>
<li><a href="https://blog.csdn.net/qq_29582173/article/details/103078900">如何实现一个简单的虚拟dom</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/135214155">尤大Vue3.0直播虚拟Dom总结(和React 对比)</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><p>手动实现一个简单的虚拟 <code>DOM</code> (类似 <code>Vue2.x</code> ， <code>React</code> 中的 <code>Fiber</code> 太过于复杂)</p>
<h1 id="创建"><a class="header" href="#创建">创建</a></h1>
<p>我们来尝试简单渲染一个 <code>DOM</code> 结构，</p>
<pre><code class="language-html">&lt;div id='app'&gt;
  &lt;p&gt;节点1&lt;/p&gt;
&lt;/div&gt;
</code></pre>
<p>我们有一个最简陋的 <code>createElement</code> 函数来返回一个虚拟 <code>DOM</code></p>
<pre><code class="language-js">const vnodeType = {
  HTML: 'HTML',
  TEXT: 'TEXT',

  COMPONENT: 'COMPONENT',
  CLASS_COMPONENT: 'CLASS_COMPONENT',
}

const childType = {
  EMPTY: 'EMPTY',
  SINGLE: 'SINGLE',
  MULTIPLE: 'MULTIPLE',
}


// 新建虚拟DOM
// 名字，属性，子元素
function createElement(tag, data, children = null) {

  let flag;
  if (typeof tag === 'string') {
    // 普通html标签
    flag = vnodeType.HTML
  } else if (typeof tag === 'function') {
    flag = vnodeType.COMPONENT
  } else {
    flag = vnodeType.TEXT
  }

  // 0， 1， n
  let childrenFlag;
  if (children == null) {
    childrenFlag = childType.EMPTY
  } else if (Array.isArray(children)) {
    let length = children.length
    if (length === 0) {
      childrenFlag = childType.EMPTY
    } else {
      childrenFlag = childType.MULTIPLE
    }
  } else {
    childrenFlag = childType.SINGLE
    children = createTextVnode(children + '')
  }


  // 返回vnode
  return {
    flag, //vnode类型
    tag, // 标签，div文本没有tag，组件就是函数
    data,
    children,
    childrenFlag
  }
}

//渲染
function render() {

}

// 创建文本类型 vnode
function createTextVnode(text) {
  return {
    flag: vnodeType.TEXT,
    tag: null,
    data: null,
    children: text,
    childrenFlag: childType.EMPTY
  }
}
</code></pre>
<p>页面上</p>
<pre><code class="language-js">let div = createElement('div', { id: 'app' }, [
    createElement('p', {}, '节点1'),
  ]);
console.log(JSON.stringify(div, null, 2))
</code></pre>
<p>out</p>
<pre><code class="language-json">{
  &quot;flag&quot;: &quot;HTML&quot;,
  &quot;tag&quot;: &quot;div&quot;,
  &quot;data&quot;: {
    &quot;id&quot;: &quot;app&quot;
  },
  &quot;children&quot;: [
    {
      &quot;flag&quot;: &quot;HTML&quot;,
      &quot;tag&quot;: &quot;p&quot;,
      &quot;data&quot;: {},
      &quot;children&quot;: {
        &quot;flag&quot;: &quot;TEXT&quot;,
        &quot;tag&quot;: null,
        &quot;data&quot;: null,
        &quot;children&quot;: &quot;节点1&quot;,
        &quot;childrenFlag&quot;: &quot;EMPTY&quot;
      },
      &quot;childrenFlag&quot;: &quot;SINGLE&quot;
    }
  ],
  &quot;childrenFlag&quot;: &quot;MULTIPLE&quot;
}
</code></pre>
<p>接下来我们将它渲染到页面上。</p>
<h1 id="渲染"><a class="header" href="#渲染">渲染</a></h1>
<p>我们搞多一些 <code>p</code> 元素在页面上，并且调用 <code>render</code> 函数来渲染。</p>
<pre><code class="language-html">&lt;html lang=&quot;en&quot;&gt;

&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot; /&gt;
  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;
  &lt;title&gt;Document&lt;/title&gt;
  &lt;style&gt;
    .item-header {
      font-size: 30px;
      color: green;
    }
  &lt;/style&gt;
&lt;/head&gt;

&lt;body&gt;
  &lt;div id='app'&gt;&lt;/div&gt;
  &lt;script src='./index.js'&gt;&lt;/script&gt;
  &lt;script&gt;
    let vnode = createElement('div', { id: 'app' }, [
      createElement('p', { key: 'a', style: { color: 'blue' } }, '节点1'),
      createElement('p', { key: 'b', '@click': () =&gt; alert('xxx') }, '节点2'),
      createElement('p', { key: 'c', 'class': 'item-header' }, '节点3'),
      createElement('p', { key: 'd' }, '节点4'),
    ]);
    render(vnode, document.getElementById('app'))
    // console.log(JSON.stringify(div, null, 2))
  &lt;/script&gt;
&lt;/body&gt;

&lt;/html&gt;
</code></pre>
<p>还有一些额外的工作（简易版本），需要注意以下的一些问题。</p>
<ul>
<li>属性的处理。</li>
<li>首次渲染和 <code>diff</code></li>
<li><code>el</code> 属性</li>
<li>递归渲染子元素</li>
</ul>
<p>简易版的代码如下:</p>
<pre><code class="language-js">const vnodeType = {
  HTML: 'HTML',
  TEXT: 'TEXT',

  COMPONENT: 'COMPONENT',
  CLASS_COMPONENT: 'CLASS_COMPONENT',
};

const childType = {
  // 节点没有子元素或者是空数组
  EMPTY: 'EMPTY',
  // 节点是文本元素
  SINGLE: 'SINGLE',
  // 节点有1或多个子元素
  MULTIPLE: 'MULTIPLE',
};

// 新建虚拟DOM
// 名字，属性，子元素
function createElement(tag, data, children = null) {
  let flag;
  if (typeof tag === 'string') {
    // 普通html标签
    flag = vnodeType.HTML;
  } else if (typeof tag === 'function') {
    flag = vnodeType.COMPONENT;
  } else {
    flag = vnodeType.TEXT;
  }

  // 0， 1， n
  let childrenFlag;
  if (children == null) {
    childrenFlag = childType.EMPTY;
  } else if (Array.isArray(children)) {
    let length = children.length;
    if (length === 0) {
      childrenFlag = childType.EMPTY;
    } else {
      childrenFlag = childType.MULTIPLE;
    }
  } else {
    childrenFlag = childType.SINGLE;
    // 文本元素直接给textVnode节点
    children = createTextVnode(children + '');
  }

  // 返回vnode
  return {
    flag, //vnode类型
    tag, // 标签，div文本没有tag，组件就是函数
    data,
    children,
    childrenFlag,
    el: null,
  };
}

//渲染
function render(vnode, container) {
  // 区分首次渲染和再次渲染
  // 首次渲染直接mount，再次渲染需要diff
  mount(vnode, container);
}

// 首次挂载元素
function mount(vnode, container) {
  let { flag } = vnode;
  // 区别对待HTML节点和Text节点
  if (flag === vnodeType.HTML) {
    mountElement(vnode, container);
  } else if (flag === vnodeType.TEXT) {
    mountText(vnode, container);
  }
}

function mountElement(vnode, container) {
  let dom = document.createElement(vnode.tag);
  // 存一下，以后都能拿到真实dom
  vnode.el = dom;
  let { data, children, childrenFlag } = vnode;

  // 挂载data属性
  if (data) {
    for (let key in data) {
      // 节点，名字，老值，新值
      patchData(dom, key, null, data[key]);
    }
  }

  // 根据子元素的不同类型来渲染子元素
  if (childrenFlag !== childType.EMPTY) {
    if (childrenFlag === childType.SINGLE) {
      mount(children, dom);
    } else if (childrenFlag == childType.MULTIPLE) {
      for (let i = 0; i &lt; children.length; i++) {
        mount(children[i], dom);
      }
    }
  }

  // 挂载
  container.appendChild(dom);
}
function mountText(vnode, container) {
  let dom = document.createTextNode(vnode.children);
  vnode.el = dom;

  // 挂载
  container.appendChild(dom);
}

function patchData(el, key, pre, next) {
  switch (key) {
    // 处理style属性
    case 'style':
      for (let k in next) {
        el.style[k] = next[k];
      }
      break;
    // 处理class属性
    case 'class':
      el.className = next;
      break;
    // 其他
    default:
      // 处理事件绑定函数，以vue的@为例
      if (key[0] === '@') {
        if (next) {
          el.addEventListener(key.slice(1), next);
        }
      } else {
        el.setAttribute(key, next)
      }
      break;
  }
}

// 创建文本类型 vnode
function createTextVnode(text) {
  return {
    flag: vnodeType.TEXT,
    tag: null,
    data: null,
    children: text,
    childrenFlag: childType.EMPTY,
    el: null,
  };
}
</code></pre>
<p>至此，虚拟 <code>DOM</code> 已经首次渲染到页面上了。</p>
<p>然后我们再来看看如何简单实现 <code>DOM diff</code>。</p>
<h1 id="patch"><a class="header" href="#patch">patch</a></h1>
<p>假设我们要将</p>
<pre><code class="language-js">let vnode = createElement('div', { id: 'app' }, [
  createElement('p', { key: 'a', style: { color: 'blue' } }, '节点1'),
  createElement('p', { key: 'b', '@click': () =&gt; alert('xxx') }, '节点2'),
  createElement('p', { key: 'c', 'class': 'item-header' }, '节点3'),
  createElement('p', { key: 'd' }, '节点4'),
]);
</code></pre>
<p>里渲染的 <code>DOM</code> ，变更为如下的 <code>DOM</code> 结构，然后在一秒后重新渲染：</p>
<pre><code class="language-js">let vnode1 = createElement(&quot;div&quot;, { id: &quot;app&quot; }, [
  createElement(&quot;p&quot;, { key: 'd' }, &quot;节点4&quot;),
  createElement(&quot;p&quot;, { key: 'a', style: { color: 'blue' } }, &quot;节点1&quot;),
  createElement(&quot;p&quot;, { key: 'b', }, &quot;节点2&quot;),
  createElement(&quot;p&quot;, { key: 'e' }, &quot;节点5&quot;),
  createElement(&quot;p&quot;, { key: 'f', style: { color: '#eee' } }, &quot;节点4&quot;),
]);

setTimeout(() =&gt; {
  render(vnode1, document.getElementById('app'))
})
</code></pre>
<p>然后我们需要在 <code>render</code> 函数里区分首次渲染和再次渲染：</p>
<pre><code class="language-js">//渲染
function render(vnode, container) {
  // 区分首次渲染和再次渲染
  // 首次渲染直接mount，再次渲染需要diff
  if (container.vnode) {
    // 更新
    patch(container.vnode, vnode, container);
  } else {
    mount(vnode, container);
  }

  container.vnode = vnode;
}
</code></pre>
<p>然后我们看一下 <code>patch</code> 函数：</p>
<pre><code class="language-js">function patch(pre, next, container) {
  let nextFlag = next.flag;
  let preFlag = pre.flag;

  // 如果flag不同直接替换。
  if (nextFlag !== preFlag) {
    // 直接替换
    repaceVnode(pre, next, container);
  } else if (nextFlag == vnodeType.HTML) {
    patchElement(pre, next, container);
  } else if (nextFlag == vnodeType.TEXT) {
    // 文本节点只需要更新文字内容即可
    patchText(pre, next);
  }
}

// 替换节点，先移除再mount
function replaceVnode(pre, next) {
  container.removeChild(pre.el);
  mount(next, container);
}

// 文本节点直接替换文字即可
function patchText(pre, next) {
  let el = (next.el = pre.el);
  if (next.children !== pre.children) {
    el.nodeValue = next.children;
  }
}
</code></pre>
<p>以上两种最简单的对比都是比较好理解的。接下来来看一下 <code>flag</code> 不同的 <code>HTML</code> 节点的替换 <code>patchElement</code> 。</p>
<pre><code class="language-js">function patchElement(pre, next, container) {
  // 如果tag不同就直接替换掉
  if (pre.tag !== next.tag) {
    repaceVnode(pre, next, container);
    return;
  }

  // 更新一下 el， 然后更新data
  let el = (next.el = pre.el);
  let preData = pre.data;
  let nextData = next.data;
  // 如果有新值，则全部更新到el上
  if (nextData) {
    for (let key in nextData) {
      let preVal = preData[key];
      let nextVal = nextData[key];
      patchData(el, key, preVal, nextVal);
    }
  }
  // 对旧值进行处理，
  // 旧的有，新的没有，就要置为空
  // 旧的有，新的有的已经在上面一个循环里被覆盖掉了。
  if (preData) {
    for (let key in preData) {
      let preVal = preData[key];
      if (preVal &amp;&amp; !nextData.hasOwnProperty(key)) {
        patchData(el, key, preVal, null);
      }
    }
  }

  // data更新完毕 下面更新子元素
  patchChildren(
    pre.childrenFlag,
    next.childrenFlag,
    pre.children,
    next.children,
    el
  );
}

// 更新子元素的方法
function patchChildren(
  preChildFlag,
  nextChildFlag,
  preChildren,
  nextChildren,
  container
) {
  // 新老元素都有三种情况，用switch case做嵌套处理
  // 更新子元素
  // 老的是 1 ， 0， n
  // 新的是 1， 0 ， n
  switch (preChildFlag) {
    // 老的是一个
    case childType.SINGLE:
      switch (nextChildFlag) {
        // 新的也是一个，直接patch
        case childType.SINGLE:
          patch(preChildren, nextChildren, container)
          break;
        // 新的是空的，直接移除老的
        case childType.EMPTY:
          container.removeChild(preChildren.el)
          break;
        // 新的是多个的，先移除老的，再循环mount新的
        case childType.MULTIPLE:
          container.removeChild(preChildren.el)
          for (let i = 0; i &lt; nextChildren.length; i++) {
            mount(nextChildren[i], container)
          }
          break;
      }
      break;
    // 老的是空的
    case childType.EMPTY:
      switch (nextChildFlag) {
        // 新的是一个，直接mount
        case childType.SINGLE:
          mount(nextChildren, container)
          break;
        // 新的也是空的，不做处理
        case childType.EMPTY:
          break;
        // 新的是多个，直接循环mount新的
        case childType.MULTIPLE:
          for (let i = 0; i &lt; nextChildren.length; i++) {
            mount(nextChildren[i], container)
          }
          break;
      }
      break;
    // 老的是多个
    case childType.MULTIPLE:
      switch (nextChildFlag) {
        // 新的是一个，循环移除老的，再把新的mount上去
        case childType.SINGLE:
          for (let i = 0; i &lt; preChildren.length; i++) {
            container.removeChild(preChildren[i]);
          }
          mount(nextChildren, container)
          break;
        // 新的是空的，循环移除老的，接下来无操作
        case childType.EMPTY:
          for (let i = 0; i &lt; preChildren.length; i++) {
            container.removeChild(preChildren[i]);
          }
          break;
        // 新的是多个的情况，比较复杂，React和Vue的实现不同。这里简单实现一下。
        // 这个算法网上都有讲解，就不赘述了。
        default:
          let lastIndex = 0
          for (let i = 0; i &lt; nextChildren.length; i++) {
            const nextVNode = nextChildren[i]
            let j = 0,
              find = false
            for (j; j &lt; preChildren.length; j++) {
              const prevVNode = preChildren[j]
              if (nextVNode.key === prevVNode.key) {
                find = true
                patch(prevVNode, nextVNode, container)
                if (j &lt; lastIndex) {
                  // 需要移动
                  const refNode = nextChildren[i - 1].el.nextSibling
                  container.insertBefore(prevVNode.el, refNode)
                  break
                } else {
                  // 更新 lastIndex
                  lastIndex = j
                }
              }
            }
            if (!find) {
              // 挂载新节点
              const refNode =
                i - 1 &lt; 0
                  ? preChildren[0].el
                  : nextChildren[i - 1].el.nextSibling

              mount(nextVNode, container, refNode)
            }
          }
          // 移除已经不存在的节点
          for (let i = 0; i &lt; preChildren.length; i++) {
            const prevVNode = preChildren[i]
            const has = nextChildren.find(
              nextVNode =&gt; nextVNode.key === prevVNode.key
            )
            if (!has) {
              // 移除
              container.removeChild(prevVNode.el)
            }
          }
          break;
      }
      break;
  }
}
</code></pre>
<p>至此，一次 <code>DOM</code> 更新就实现了。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="react事件机制"><a class="header" href="#react事件机制">React事件机制</a></h1>
<h2 id="dom事件"><a class="header" href="#dom事件">DOM事件</a></h2>
<p>冒泡和捕获</p>
<p><img src="React/./images/image-20210624173959717.png" alt="image-20210624173959717" /></p>
<p>先从父元素向下传递捕获，直到子元素处理掉，然后再逐个冒泡。</p>
<p>所以有了一个事件委托的机制。</p>
<h2 id="react事件"><a class="header" href="#react事件">React事件</a></h2>
<p>React会将所有事件都绑定在document上。</p>
<p>统一使用事件监听。都是在冒泡阶段处理。</p>
<p>所以一般在组件挂载的时候增加监听事件。</p>
<p>组件卸载的时候删除监听事件。</p>
<p>事件触发的时候，组件会生成一个合成事件。然后发送到document上。</p>
<p>document会通过dispatch event回调函数依次执行dispatch listener中同类型事件的监听函数。</p>
<p>事件注册是在组件生成的时候，将VDOM中的所有的事件对应的原生事件都注册在Document中一个监听器中。所有的事件处理函数都存放在listenerbank中，并以key做为索引。（将可能要触发的事件分门别类）</p>
<ol>
<li>是合成事件，不是DOM原生事件</li>
<li>在document监听所有支持事件</li>
<li>使用统一的分发函数dispatchEvent来指定事件函数的执行</li>
</ol>
<p><a href="https://juejin.cn/post/6844903502729183239">拓展阅读1</a></p>
<p><a href="http://zhenhua-lee.github.io/react/react-event.html">拓展阅读2</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="react合成事件"><a class="header" href="#react合成事件">React合成事件</a></h1>
<p><a href="https://zhuanlan.zhihu.com/p/25883536">原文</a></p>
<p><a href="https://react.html.cn/docs/events.html">其他参考</a></p>
<h2 id="1-react合成事件特点"><a class="header" href="#1-react合成事件特点">1 React合成事件特点</a></h2>
<p>React自己实现了一套高效的事件注册，存储，分发和重用逻辑，在DOM事件体系基础上做了很大改进，减少了内存消耗，简化了事件逻辑，并最大化的解决了IE等浏览器的不兼容问题。与DOM事件体系相比，它有如下特点</p>
<ol>
<li>React组件上声明的事件最终绑定到了document这个DOM节点上，而不是React组件对应的DOM节点。故只有document这个节点上面才绑定了DOM原生事件，其他节点没有绑定事件。这样简化了DOM原生事件，减少了内存开销</li>
<li>React以队列的方式，从触发事件的组件向父组件回溯，调用它们在JSX中声明的callback。也就是React自身实现了一套事件冒泡机制。我们没办法用event.stopPropagation()来停止事件传播，应该使用event.preventDefault()</li>
<li>React有一套自己的合成事件SyntheticEvent，不同类型的事件会构造不同的SyntheticEvent</li>
<li>React使用对象池来管理合成事件对象的创建和销毁，这样减少了垃圾的生成和新对象内存的分配，大大提高了性能</li>
</ol>
<p>那么这些特性是如何实现的呢，下面和大家一起一探究竟。</p>
<h2 id="2-react事件系统"><a class="header" href="#2-react事件系统">2 React事件系统</a></h2>
<p>先看Facebook给出的React事件系统框图</p>
<p>浏览器事件（如用户点击了某个button）触发后，DOM将event传给ReactEventListener，它将事件分发到当前组件及以上的父组件。然后由ReactEventEmitter对每个组件进行事件的执行，先构造React合成事件，然后以queue的方式调用JSX中声明的callback进行事件回调。</p>
<p>涉及到的主要类如下</p>
<p>ReactEventListener：负责事件注册和事件分发。React将DOM事件全都注册到document这个节点上，这个我们在事件注册小节详细讲。事件分发主要调用dispatchEvent进行，从事件触发组件开始，向父元素遍历。我们在事件执行小节详细讲。</p>
<p>ReactEventEmitter：负责每个组件上事件的执行。</p>
<p>EventPluginHub：负责事件的存储，合成事件以对象池的方式实现创建和销毁，大大提高了性能。</p>
<p>SimpleEventPlugin等plugin：根据不同的事件类型，构造不同的合成事件。如focus对应的React合成事件为SyntheticFocusEvent</p>
<h2 id="2-事件注册"><a class="header" href="#2-事件注册">2 事件注册</a></h2>
<p>JSX中声明一个React事件十分简单，比如</p>
<pre><code class="language-js">render() {
  return (
    &lt;div onClick = {
            (event) =&gt; {console.log(JSON.stringify(event))}
        } 
    /&gt;
  );
}
</code></pre>
<p>那么它是如何被注册到React事件系统中的呢？</p>
<p>还是先得从组件创建和更新的入口方法mountComponent和updateComponent说起。在这两个方法中，都会调用到_updateDOMProperties方法，对JSX中声明的组件属性进行处理。源码如下</p>
<pre><code class="language-js">_updateDOMProperties: function (lastProps, nextProps, transaction) {
    ... // 前面代码太长，省略一部分
    else if (registrationNameModules.hasOwnProperty(propKey)) {
        // 如果是props这个对象直接声明的属性，而不是从原型链中继承而来的，则处理它
        // nextProp表示要创建或者更新的属性，而lastProp则表示上一次的属性
        // 对于mountComponent，lastProp为null。updateComponent二者都不为null。unmountComponent则nextProp为null
        if (nextProp) {
          // mountComponent和updateComponent中，enqueuePutListener注册事件
          enqueuePutListener(this, propKey, nextProp, transaction);
        } else if (lastProp) {
          // unmountComponent中，删除注册的listener，防止内存泄漏
          deleteListener(this, propKey);
        }
    }
}
</code></pre>
<p>下面我们来看enqueuePutListener，它负责注册JSX中声明的事件。源码如下</p>
<pre><code class="language-js">// inst: React Component对象
// registrationName: React合成事件名，如onClick
// listener: React事件回调方法，如onClick=callback中的callback
// transaction: mountComponent或updateComponent所处的事务流中，React都是基于事务流的
function enqueuePutListener(inst, registrationName, listener, transaction) {
  if (transaction instanceof ReactServerRenderingTransaction) {
    return;
  }
  var containerInfo = inst._hostContainerInfo;
  var isDocumentFragment = containerInfo._node &amp;&amp; containerInfo._node.nodeType === DOC_FRAGMENT_TYPE;
  // 找到document
  var doc = isDocumentFragment ? containerInfo._node : containerInfo._ownerDocument;
  // 注册事件，将事件注册到document上
  listenTo(registrationName, doc);
  // 存储事件,放入事务队列中
  transaction.getReactMountReady().enqueue(putListener, {
    inst: inst,
    registrationName: registrationName,
    listener: listener
  });
}
</code></pre>
<p>enqueuePutListener主要做两件事，一方面将事件注册到document这个原生DOM上（这就是为什么只有document这个节点有DOM事件的原因），另一方面采用事务队列的方式调用putListener将注册的事件存储起来，以供事件触发时回调。</p>
<p>注册事件的入口是listenTo方法,
它解决了不同浏览器间捕获和冒泡不兼容的问题。事件回调方法在bubble阶段被触发。如果我们想让它在capture阶段触发，则需要在事件名上加上capture。比如onClick在bubble阶段触发，而onCaptureClick在capture阶段触发。listenTo代码虽然比较长，但逻辑很简单，调用trapCapturedEvent和trapBubbledEvent来注册捕获和冒泡事件。trapCapturedEvent大家可以自行分析，我们仅分析trapBubbledEvent，如下</p>
<pre><code class="language-js">trapBubbledEvent: function (topLevelType, handlerBaseName, element) {
    if (!element) {
      return null;
    }
    return EventListener.listen(
      element,   // 绑定到的DOM目标,也就是document
      handlerBaseName,   // eventType
      ReactEventListener.dispatchEvent.bind(null, topLevelType));  // callback, document上的原生事件触发后回调
  },

  listen: function listen(target, eventType, callback) {
    if (target.addEventListener) {
      // 将原生事件添加到target这个dom上,也就是document上。
      // 这就是只有document这个DOM节点上有原生事件的原因
      target.addEventListener(eventType, callback, false);
      return {
        // 删除事件,这个由React自己回调,不需要调用者来销毁。但仅仅对于React合成事件才行
        remove: function remove() {
          target.removeEventListener(eventType, callback, false);
        }
      };
    } else if (target.attachEvent) {
      // attach和detach的方式
      target.attachEvent('on' + eventType, callback);
      return {
        remove: function remove() {
          target.detachEvent('on' + eventType, callback);
        }
      };
    }
  },
</code></pre>
<p>在listen方法中，我们终于发现了熟悉的addEventListener这个原生事件注册方法。只有document节点才会调用这个方法，故仅仅只有document节点上才有DOM事件。这大大简化了DOM事件逻辑，也节约了内存。</p>
<p>流程图如下</p>
<h2 id="3-事件存储"><a class="header" href="#3-事件存储">3 事件存储</a></h2>
<p>事件存储由EventPluginHub来负责，它的入口在我们上面讲到的enqueuePutListener中的putListener方法，如下</p>
<pre><code class="language-js">/**
   * EventPluginHub用来存储React事件, 将listener存储到`listenerBank[registrationName][key]`
   *
   * @param {object} inst: 事件源
   * @param {string} listener的名字,比如onClick
   * @param {function} listener的callback
   */
  //
  putListener: function (inst, registrationName, listener) {

    // 用来标识注册了事件,比如onClick的React对象。key的格式为'.nodeId', 只用知道它可以标示哪个React对象就可以了
    var key = getDictionaryKey(inst);
    var bankForRegistrationName = listenerBank[registrationName] || (listenerBank[registrationName] = {});
    // 将listener事件回调方法存入listenerBank[registrationName][key]中,比如listenerBank['onclick'][nodeId]
    // 所有React组件对象定义的所有React事件都会存储在listenerBank中
    bankForRegistrationName[key] = listener;

    //onSelect和onClick注册了两个事件回调插件, 用于walkAround某些浏览器兼容bug,不用care
    var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
    if (PluginModule &amp;&amp; PluginModule.didPutListener) {
      PluginModule.didPutListener(inst, registrationName, listener);
    }
  },

var getDictionaryKey = function (inst) {
  return '.' + inst._rootNodeID;
};
</code></pre>
<p>由上可见，事件存储在了listenerBank对象中，它按照事件名和React组件对象进行了二维划分，比如nodeId组件上注册的onClick事件最后存储在listenerBank.onclick[nodeId]中。</p>
<h2 id="4-事件执行"><a class="header" href="#4-事件执行">4 事件执行</a></h2>
<h2 id="41-事件分发"><a class="header" href="#41-事件分发">4.1 事件分发</a></h2>
<p>当事件触发时，document上addEventListener注册的callback会被回调。从前面事件注册部分发现，此时回调函数为ReactEventListener.dispatchEvent，它是事件分发的入口方法。下面我们来详细分析</p>
<pre><code class="language-js">// topLevelType：带top的事件名，如topClick。不用纠结为什么带一个top字段，知道它是事件名就OK了
// nativeEvent: 用户触发click等事件时，浏览器传递的原生事件
dispatchEvent: function (topLevelType, nativeEvent) {
    // disable了则直接不回调相关方法
    if (!ReactEventListener._enabled) {
      return;
    }

    var bookKeeping = TopLevelCallbackBookKeeping.getPooled(topLevelType, nativeEvent);
    try {
      // 放入批处理队列中,React事件流也是一个消息队列的方式
      ReactUpdates.batchedUpdates(handleTopLevelImpl, bookKeeping);
    } finally {
      TopLevelCallbackBookKeeping.release(bookKeeping);
    }
}
</code></pre>
<p>可见我们仍然使用批处理的方式进行事件分发，handleTopLevelImpl才是事件分发的真正执行者，它是事件分发的核心，体现了React事件分发的特点，如下</p>
<pre><code class="language-js">// document进行事件分发,这样具体的React组件才能得到响应。因为DOM事件是绑定到document上的
function handleTopLevelImpl(bookKeeping) {
  // 找到事件触发的DOM和React Component
  var nativeEventTarget = getEventTarget(bookKeeping.nativeEvent);
  var targetInst = ReactDOMComponentTree.getClosestInstanceFromNode(nativeEventTarget);

  // 执行事件回调前,先由当前组件向上遍历它的所有父组件。得到ancestors这个数组。
  // 因为事件回调中可能会改变Virtual DOM结构,所以要先遍历好组件层级
  var ancestor = targetInst;
  do {
    bookKeeping.ancestors.push(ancestor);
    ancestor = ancestor &amp;&amp; findParent(ancestor);
  } while (ancestor);

  // 从当前组件向父组件遍历,依次执行注册的回调方法. 我们遍历构造ancestors数组时,是从当前组件向父组件回溯的,故此处事件回调也是这个顺序
  // 这个顺序就是冒泡的顺序,并且我们发现不能通过stopPropagation来阻止'冒泡'。
  for (var i = 0; i &lt; bookKeeping.ancestors.length; i++) {
    targetInst = bookKeeping.ancestors[i];
    ReactEventListener._handleTopLevel(bookKeeping.topLevelType, targetInst, bookKeeping.nativeEvent, getEventTarget(bookKeeping.nativeEvent));
  }
}
</code></pre>
<p>从上面的事件分发中可见，React自身实现了一套冒泡机制。从触发事件的对象开始，向父元素回溯，依次调用它们注册的事件callback。</p>
<h2 id="42-事件callback调用"><a class="header" href="#42-事件callback调用">4.2 事件callback调用</a></h2>
<p>事件处理由_handleTopLevel完成。它其实是调用ReactBrowserEventEmitter.handleTopLevel() ，如下</p>
<pre><code class="language-js">// React事件调用的入口。DOM事件绑定在了document原生对象上,每次事件触发,都会调用到handleTopLevel
  handleTopLevel: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    // 采用对象池的方式构造出合成事件。不同的eventType的合成事件可能不同
    var events = EventPluginHub.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);
    // 批处理队列中的events
    runEventQueueInBatch(events);
  }
</code></pre>
<p>handleTopLevel方法是事件callback调用的核心。它主要做两件事情，一方面利用浏览器回传的原生事件构造出React合成事件，另一方面采用队列的方式处理events。先看如何构造合成事件。</p>
<h2 id="421-构造合成事件"><a class="header" href="#421-构造合成事件">4.2.1 构造合成事件</a></h2>
<pre><code class="language-js">// 构造合成事件
  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    var events;
    // EventPluginHub可以存储React合成事件的callback,也存储了一些plugin,这些plugin在EventPluginHub初始化时就注册就来了
    var plugins = EventPluginRegistry.plugins;
    for (var i = 0; i &lt; plugins.length; i++) {
      var possiblePlugin = plugins[i];
      if (possiblePlugin) {
        // 根据eventType构造不同的合成事件SyntheticEvent
        var extractedEvents = possiblePlugin.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);
        if (extractedEvents) {
          // 将构造好的合成事件extractedEvents添加到events数组中,这样就保存了所有plugin构造的合成事件
          events = accumulateInto(events, extractedEvents);
        }
      }
    }
    return events;
  },
</code></pre>
<p>EventPluginRegistry.plugins默认包含五种plugin，他们是在EventPluginHub初始化阶段注入进去的，且看代码</p>
<pre><code class="language-js">// 将eventPlugin注册到EventPluginHub中
  ReactInjection.EventPluginHub.injectEventPluginsByName({
    SimpleEventPlugin: SimpleEventPlugin,
    EnterLeaveEventPlugin: EnterLeaveEventPlugin,
    ChangeEventPlugin: ChangeEventPlugin,
    SelectEventPlugin: SelectEventPlugin,
    BeforeInputEventPlugin: BeforeInputEventPlugin
  });
</code></pre>
<p>不同的plugin针对不同的事件有特殊的处理，此处我们不展开讲了，下面仅分析SimpleEventPlugin中方法即可。</p>
<p>我们先看SimpleEventPlugin如何构造它所对应的React合成事件。</p>
<pre><code class="language-js">// 根据不同事件类型,比如click,focus构造不同的合成事件SyntheticEvent, 如SyntheticKeyboardEvent SyntheticFocusEvent
extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    var dispatchConfig = topLevelEventsToDispatchConfig[topLevelType];
    if (!dispatchConfig) {
      return null;
    }
    var EventConstructor;

   // 根据事件类型，采用不同的SyntheticEvent来构造不同的合成事件
    switch (topLevelType) {
      ... // 省略一些事件，我们仅以blur和focus为例
      case 'topBlur':
      case 'topFocus':
        EventConstructor = SyntheticFocusEvent;
        break;
      ... // 省略一些事件
    }

    // 从event对象池中取出合成事件对象,利用对象池思想,可以大大降低对象创建和销毁的时间,提高性能。这是React事件系统的一大亮点
    var event = EventConstructor.getPooled(dispatchConfig, targetInst, nativeEvent, nativeEventTarget);
    EventPropagators.accumulateTwoPhaseDispatches(event);
    return event;
},
</code></pre>
<p>这里我们看到了event对象池这个重大特性，采用合成事件对象池的方式，可以大大降低销毁和创建合成事件带来的性能开销。</p>
<p>对象创建好之后，我们还会将它添加到events这个队列中，因为事件回调的时候会用到这个队列。添加到events中使用的是accumulateInto方法。它思路比较简单，将新创建的合成对象的引用添加到之前创建好的events队列中即可，源码如下</p>
<pre><code class="language-js">function accumulateInto(current, next) {

  if (current == null) {
    return next;
  }

  // 将next添加到current中,返回一个包含他们两个的新数组
  // 如果next是数组,current不是数组,采用push方法,否则采用concat方法
  // 如果next不是数组,则返回一个current和next构成的新数组
  if (Array.isArray(current)) {
    if (Array.isArray(next)) {
      current.push.apply(current, next);
      return current;
    }
    current.push(next);
    return current;
  }

  if (Array.isArray(next)) {
    return [current].concat(next);
  }

  return [current, next];
}
</code></pre>
<h2 id="422-批处理合成事件"><a class="header" href="#422-批处理合成事件">4.2.2 批处理合成事件</a></h2>
<p>我们上面分析过了，React以队列的形式处理合成事件。方法入口为runEventQueueInBatch，如下</p>
<pre><code class="language-js">function runEventQueueInBatch(events) {
    // 先将events事件放入队列中
    EventPluginHub.enqueueEvents(events);
    // 再处理队列中的事件,包括之前未处理完的。先入先处理原则
    EventPluginHub.processEventQueue(false);
  }

  /**
   * syntheticEvent放入队列中,等到processEventQueue再获得执行
   */
  enqueueEvents: function (events) {
    if (events) {
      eventQueue = accumulateInto(eventQueue, events);
    }
  },

  /**
   * 分发执行队列中的React合成事件。React事件是采用消息队列方式批处理的
   *
   * simulated：为true表示React测试代码，我们一般都是false 
   */
  processEventQueue: function (simulated) {
    // 先将eventQueue重置为空
    var processingEventQueue = eventQueue;
    eventQueue = null;
    if (simulated) {
      forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseSimulated);
    } else {
      // 遍历处理队列中的事件,
      // 如果只有一个元素,则直接executeDispatchesAndReleaseTopLevel(processingEventQueue)
      // 否则遍历队列中事件,调用executeDispatchesAndReleaseTopLevel处理每个元素
      forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseTopLevel);
    }
    // This would be a good time to rethrow if any of the event handlers threw.
    ReactErrorUtils.rethrowCaughtError();
  },
</code></pre>
<p>合成事件处理也分为两步，先将我们要处理的events队列放入eventQueue中，因为之前可能就存在还没处理完的合成事件。然后再执行eventQueue中的事件。可见，如果之前有事件未处理完，这里就又有得到执行的机会了。</p>
<p>事件执行的入口方法为executeDispatchesAndReleaseTopLevel，如下</p>
<pre><code class="language-js">var executeDispatchesAndReleaseTopLevel = function (e) {
  return executeDispatchesAndRelease(e, false);
};

var executeDispatchesAndRelease = function (event, simulated) {
  if (event) {
    // 进行事件分发,
    EventPluginUtils.executeDispatchesInOrder(event, simulated);

    if (!event.isPersistent()) {
      // 处理完,则release掉event对象,采用对象池方式,减少GC
      // React帮我们处理了合成事件的回收机制，不需要我们关心。但要注意，如果使用了DOM原生事件，则要自己回收
      event.constructor.release(event);
    }
  }
};

// 事件处理的核心
function executeDispatchesInOrder(event, simulated) {
  var dispatchListeners = event._dispatchListeners;
  var dispatchInstances = event._dispatchInstances;

  if (Array.isArray(dispatchListeners)) {
    // 如果有多个listener,则遍历执行数组中event
    for (var i = 0; i &lt; dispatchListeners.length; i++) {
      // 如果isPropagationStopped设成true了,则停止事件传播,退出循环。
      if (event.isPropagationStopped()) {
        break;
      }
      // 执行event的分发,从当前触发事件元素向父元素遍历
      // event为浏览器上传的原生事件
      // dispatchListeners[i]为JSX中声明的事件callback
      // dispatchInstances[i]为对应的React Component 
      executeDispatch(event, simulated, dispatchListeners[i], dispatchInstances[i]);
    }
  } else if (dispatchListeners) {
    // 如果只有一个listener,则直接执行事件分发
    executeDispatch(event, simulated, dispatchListeners, dispatchInstances);
  }
  // 处理完event,重置变量。因为使用的对象池,故必须重置,这样才能被别人复用
  event._dispatchListeners = null;
  event._dispatchInstances = null;
}
</code></pre>
<p>executeDispatchesInOrder会先得到event对应的listeners队列，然后从当前元素向父元素遍历执行注册的callback。且看executeDispatch</p>
<pre><code class="language-js">function executeDispatch(event, simulated, listener, inst) {
  var type = event.type || 'unknown-event';
  event.currentTarget = EventPluginUtils.getNodeFromInstance(inst);
  if (simulated) {
    // test代码使用,支持try-catch,其他就没啥区别了
    ReactErrorUtils.invokeGuardedCallbackWithCatch(type, listener, event);
  } else {
    // 事件分发,listener为callback,event为参数,类似listener(event)这个方法调用
    // 这样就回调到了我们在JSX中注册的callback。比如onClick={(event) =&gt; {console.log(1)}}
    // 这样应该就明白了callback怎么被调用的,以及event参数怎么传入callback里面的了
    ReactErrorUtils.invokeGuardedCallback(type, listener, event);
  }
  event.currentTarget = null;
}

// 采用func(a)的方式进行调用，
// 故ReactErrorUtils.invokeGuardedCallback(type, listener, event)最终调用的是listener(event)
// event对象为浏览器传递的DOM原生事件对象，这也就解释了为什么React合成事件回调中能拿到原生event的原因
function invokeGuardedCallback(name, func, a) {
  try {
    func(a);
  } catch (x) {
    if (caughtError === null) {
      caughtError = x;
    }
  }
}
</code></pre>
<h2 id="5-总结"><a class="header" href="#5-总结">5 总结</a></h2>
<p>React事件系统还是相当麻烦的，主要分为事件注册，事件存储和事件执行三大部分。了解了React事件系统源码，就能够轻松回答我们文章开头所列出的React事件几大特点了。</p>
<p>由于事件系统相当麻烦，文章中不正确的地方，请不吝赐教！</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="react-hooks-详解-近-1w-字-项目实战"><a class="header" href="#react-hooks-详解-近-1w-字-项目实战">React Hooks 详解 【近 1W 字】+ 项目实战</a></h1>
<p><a href="https://juejin.cn/post/6844903985338400782">引用</a></p>
<h1 id="react-hooks"><a class="header" href="#react-hooks">React Hooks</a></h1>
<h2 id="一什么是-hooks"><a class="header" href="#一什么是-hooks">一、什么是 Hooks</a></h2>
<ul>
<li>React 一直都提倡使用_<strong>函数组件</strong> <em>，但是有时候需要使用 state 或者其他一些功能时，只能使用</em> <strong>类组件</strong>_，因为函数组件没有实例，没有生命周期函数，只有类组件才有</li>
<li>Hooks 是 React 16.8 新增的特性，它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性</li>
<li>如果你在编写函数组件并意识到需要向其添加一些 state，以前的做法是必须将其它转化为 class。现在你可以直接在现有的函数组件中使用 Hooks</li>
<li>凡是 use 开头的 React API 都是 Hooks</li>
</ul>
<h2 id="二hooks-解决的问题"><a class="header" href="#二hooks-解决的问题">二、Hooks 解决的问题</a></h2>
<h3 id="1-类组件的不足"><a class="header" href="#1-类组件的不足">1. 类组件的不足</a></h3>
<ul>
<li>
<p><strong>状态逻辑难复用：</strong> 在组件之间复用状态逻辑很难，可能要用到 <strong>render props</strong> （<strong>渲染属性</strong>）或者
<strong>HOC</strong>（<strong>高阶组件</strong>），但无论是渲染属性，还是高阶组件，都会在原先的组件外包裹一层父容器（一般都是 div 元素），<strong>导致层级冗余</strong></p>
</li>
<li>
<p>趋向复杂难以维护：</p>
<ul>
<li>在生命周期函数中混杂不相干的逻辑（如：在 <code>componentDidMount</code> 中注册事件以及其他的逻辑，在 <code>componentWillUnmount</code>
中卸载事件，这样分散不集中的写法，很容易写出 bug ）</li>
<li>类组件中到处都是对状态的访问和处理，导致组件难以拆分成更小的组件</li>
</ul>
</li>
<li>
<p>this 指向问题</p>
<ul>
<li>
<p>父组件给子组件传递函数时，必须绑定 this</p>
</li>
<li>
<p>react 中的组件四种绑定 this 方法的区别</p>
</li>
</ul>
</li>
</ul>
<pre><code class="language-javascript">class App extends React.Component&lt;any, any&gt; {
    handleClick2;

    constructor(props) {
        super(props);
        this.state = {
            num: 1,
            title: ' react study'
        };
        this.handleClick2 = this.handleClick1.bind(this);
    }

    handleClick1() {
        this.setState({
            num: this.state.num + 1,
        })
    }

    handleClick3 = () =&gt; {
        this.setState({
            num: this.state.num + 1,
        })
    };

    render() {
        return (&lt;div&gt;
            &lt;h2&gt;Ann, {this.state.num}&lt;/h2&gt;
            &lt;button onClick={this.handleClick2}&gt;btn1&lt;/button&gt;
            &lt;button onClick={this.handleClick1.bind(this)}&gt;btn2&lt;/button&gt;
            &lt;button onClick={() =&gt; this.handleClick1()}&gt;btn3&lt;/button&gt;
            &lt;button onClick={this.handleClick3}&gt;btn4&lt;/button&gt;
        &lt;/div&gt;)
    }
}
</code></pre>
<p>前提：子组件内部做了性能优化，如（<strong>React.PureComponent</strong>）</p>
<ul>
<li>第一种是<strong>在构造函数中绑定 this</strong>：那么每次父组件刷新的时候，如果传递给子组件其他的 props 值不变，那么子组件就不会刷新；</li>
<li>第二种是<strong>在 render() 函数里面绑定 this</strong>：因为 <strong>bind 函数会返回一个新的函数</strong>，所以每次父组件刷新时，都会重新生成一个函数，即使父组件传递给子组件其他的 props
值不变，子组件每次都会刷新；</li>
<li>第三种是<strong>使用箭头函数</strong>：父组件刷新的时候，即使两个箭头函数的函数体是一样的，都会生成一个新的箭头函数，所以子组件每次都会刷新；</li>
<li>第四种是<strong>使用类的静态属性：原理和第一种方法差不多，比第一种更简洁</strong></li>
</ul>
<p>综上所述，如果不注意的话，很容易写成第三种写法，导致性能上有所损耗。</p>
<h3 id="2-hooks-优势"><a class="header" href="#2-hooks-优势">2. Hooks 优势</a></h3>
<ul>
<li>能优化类组件的三大问题</li>
<li>能在无需修改组件结构的情况下复用状态逻辑（自定义 Hooks ）</li>
<li>能将组件中相互关联的部分拆分成更小的函数（比如设置订阅或请求数据）</li>
<li><strong>副作用的关注点分离</strong>：<strong>副作用指那些没有发生在数据向视图转换过程中的逻辑，如 <code>ajax</code> 请求、访问原生<code>dom</code>
元素、本地持久化缓存、绑定/解绑事件、添加订阅、设置定时器、记录日志等</strong>。以往这些副作用都是写在类组件生命周期函数中的。而 <code>useEffect</code>
在全部渲染完毕后才会执行，<code>useLayoutEffect</code> 会在浏览器 <code>layout</code> 之后，<code>painting</code> 之前执行。</li>
</ul>
<h2 id="三注意事项"><a class="header" href="#三注意事项">三、注意事项</a></h2>
<ul>
<li><strong>只能在函数内部的最外层调用 Hook，不要在循环、条件判断或者子函数中调用</strong></li>
<li><strong>只能在 React 的函数组件中调用 Hook，不要在其他 JavaScript 函数中调用</strong></li>
<li><a href="https://reactjs.org/warnings/invalid-hook-call-warning.html"><strong>https://reactjs.org/warnings/invalid-hook-call-warning.html</strong></a></li>
</ul>
<h2 id="四usestate--usememo--usecallback"><a class="header" href="#四usestate--usememo--usecallback">四、useState &amp; useMemo &amp; useCallback</a></h2>
<ul>
<li>
<p><strong>React 假设当你多次调用 useState 的时候，你能保证每次渲染时它们的调用顺序是不变的。</strong></p>
</li>
<li>
<p>通过在函数组件里调用它来给组件添加一些内部 state，React会 <strong>在重复渲染时保留这个 state</strong></p>
</li>
<li>
<p>useState 唯一的参数就是初始 state</p>
</li>
<li>
<p>useState 会返回一个数组</p>
<ul>
<li>
<p>一个 state，一个更新 state 的函数</p>
</li>
<li>
<p>在初始化渲染期间，返回的状态 (state) 与传入的第一个参数 (initialState) 值相同</p>
</li>
</ul>
</li>
<li>
<p>你可以在事件处理函数中或其他一些地方调用这个函数。它类似 class 组件的 this.setState，但是它<strong>不会把新的 state 和旧的 state 进行合并，而是直接替换</strong></p>
</li>
</ul>
<pre><code class="language-javascript">// 这里可以任意命名，因为返回的是数组，数组解构
const [state, setState] = useState(initialState);
</code></pre>
<h3 id="41-使用例子"><a class="header" href="#41-使用例子">4.1 使用例子</a></h3>
<pre><code class="language-javascript">import React, { useState } from &quot;react&quot;;
import ReactDOM from &quot;react-dom&quot;;

function Child1(porps) {
  console.log(porps);
  const { num, handleClick } = porps;
  return (
    &lt;div
      onClick={() =&gt; {
        handleClick(num + 1);
      }}
    &gt;
      child
    &lt;/div&gt;
  );
}

function Child2(porps) {
  // console.log(porps);
  const { text, handleClick } = porps;
  return (
    &lt;div&gt;
      child2
      &lt;Grandson text={text} handleClick={handleClick} /&gt;
    &lt;/div&gt;
  );
}

function Grandson(porps) {
  console.log(porps);
  const { text, handleClick } = porps;
  return (
    &lt;div
      onClick={() =&gt; {
        handleClick(text + 1);
      }}
    &gt;
      grandson
    &lt;/div&gt;
  );
}

function Parent() {
  let [num, setNum] = useState(0);
  let [text, setText] = useState(1);

  return (
    &lt;div&gt;
      &lt;Child1 num={num} handleClick={setNum} /&gt;
      &lt;Child2 text={text} handleClick={setText} /&gt;
    &lt;/div&gt;
  );
}

const rootElement = document.getElementById(&quot;root&quot;);
ReactDOM.render(&lt;Parent /&gt;, rootElement);
</code></pre>
<h3 id="42-每次渲染都是独立的闭包"><a class="header" href="#42-每次渲染都是独立的闭包">4.2 每次渲染都是独立的闭包</a></h3>
<ul>
<li>每一次渲染都有它自己的 Props 和 State</li>
<li>每一次渲染都有它自己的事件处理函数</li>
<li>当点击更新状态的时候，函数组件都会重新被调用，那么每次渲染都是独立的，取到的值不会受后面操作的影响</li>
</ul>
<pre><code class="language-javascript">function Counter2(){
  let [number,setNumber] = useState(0);
  function alertNumber(){
    setTimeout(()=&gt;{
      // alert 只能获取到点击按钮时的那个状态
      alert(number);
    },3000);
  }
  return (
      &lt;&gt;
          &lt;p&gt;{number}&lt;/p&gt;
          &lt;button onClick={()=&gt;setNumber(number+1)}&gt;+&lt;/button&gt;
          &lt;button onClick={alertNumber}&gt;alertNumber&lt;/button&gt;
      &lt;/&gt;
  )
}
</code></pre>
<h3 id="43-函数式更新"><a class="header" href="#43-函数式更新">4.3 函数式更新</a></h3>
<ul>
<li><strong>如果新的 state 需要通过使用先前的 state 计算得出，那么可以将回调函数当做参数传递给 setState。该回调函数将接收先前的 state，并返回一个更新后的值。</strong></li>
</ul>
<pre><code class="language-javascript">function Counter(){
    let [number,setNumber] = useState(0);
    function lazy(){
        setTimeout(() =&gt; {
            // setNumber(number+1);
            // 这样每次执行时都会去获取一遍 state，而不是使用点击触发时的那个 state
            setNumber(number=&gt;number+1);
        }, 3000);
    }
    return (
        &lt;&gt;
           &lt;p&gt;{number}&lt;/p&gt;
           &lt;button onClick={()=&gt;setNumber(number+1)}&gt;+&lt;/button&gt;
           &lt;button onClick={lazy}&gt;lazy&lt;/button&gt;
        &lt;/&gt;
    )
}
</code></pre>
<h3 id="44-惰性初始化-state"><a class="header" href="#44-惰性初始化-state">4.4 惰性初始化 state</a></h3>
<ul>
<li><strong>initialState 参数只会在组件的初始化渲染中起作用，后续渲染时会被忽略</strong></li>
<li><strong>如果初始 state 需要通过复杂计算获得，则可以传入一个函数，在函数中计算并返回初始的 state，此函数只在初始渲染时被调用</strong></li>
</ul>
<pre><code class="language-javascript">function Counter5(props){
    console.log('Counter5 render');
    // 这个函数只在初始渲染时执行一次，后续更新状态重新渲染组件时，该函数就不会再被调用
    function getInitState(){
        return {number:props.number};
    }
    let [counter,setCounter] = useState(getInitState);
    return (
        &lt;&gt;
           &lt;p&gt;{counter.number}&lt;/p&gt;
           &lt;button onClick={()=&gt;setCounter({number:counter.number+1})}&gt;+&lt;/button&gt;
           &lt;button onClick={()=&gt;setCounter(counter)}&gt;setCounter&lt;/button&gt;
        &lt;/&gt;
    )
}
</code></pre>
<h3 id="45-性能优化"><a class="header" href="#45-性能优化">4.5 性能优化</a></h3>
<h4 id="451-objectis-浅比较"><a class="header" href="#451-objectis-浅比较">4.5.1 Object.is （浅比较）</a></h4>
<ul>
<li>Hook 内部使用 Object.is 来比较新/旧 state 是否相等</li>
<li><strong>与 class 组件中的 setState 方法不同，如果你修改状态的时候，传的状态值没有变化，则不重新渲染</strong></li>
<li><strong>与 class 组件中的 setState 方法不同，useState 不会自动合并更新对象。你可以用函数式的 setState 结合展开运算符来达到合并更新对象的效果</strong></li>
</ul>
<pre><code class="language-javascript">function Counter(){
    const [counter,setCounter] = useState({name:'计数器',number:0});
    console.log('render Counter')
    // 如果你修改状态的时候，传的状态值没有变化，则不重新渲染
    return (
        &lt;&gt;
            &lt;p&gt;{counter.name}:{counter.number}&lt;/p&gt;
            &lt;button onClick={()=&gt;setCounter({...counter,number:counter.number+1})}&gt;+&lt;/button&gt;
            &lt;button onClick={()=&gt;setCounter(counter)}&gt;++&lt;/button&gt;
        &lt;/&gt;
    )
}
</code></pre>
<h4 id="452-减少渲染次数"><a class="header" href="#452-减少渲染次数">4.5.2 减少渲染次数</a></h4>
<ul>
<li><strong>默认情况，只要父组件状态变了（不管子组件依不依赖该状态），子组件也会重新渲染</strong></li>
<li>一般的优化：
<ol>
<li><strong>类组件</strong>：可以使用 <code>pureComponent</code> ；</li>
<li><strong>函数组件</strong>：使用 <code>React.memo</code> ，将函数组件传递给 <code>memo</code> 之后，就会返回一个新的组件，新组件的功能：<strong>如果接受到的属性不变，则不重新渲染函数</strong>；</li>
</ol>
</li>
<li><strong>但是怎么保证属性不会变尼？这里使用 useState ，每次更新都是独立的</strong>，<code>const [number,setNumber] = useState(0)</code>
<strong>也就是说每次都会生成一个新的值（哪怕这个值没有变化），即使使用了 <code>React.memo</code> ，也还是会重新渲染</strong></li>
</ul>
<pre><code class="language-javascript">import React,{useState,memo,useMemo,useCallback} from 'react';

function SubCounter({onClick,data}){
    console.log('SubCounter render');
    return (
        &lt;button onClick={onClick}&gt;{data.number}&lt;/button&gt;
    )
}
SubCounter = memo(SubCounter);
export  default  function Counter6(){
    console.log('Counter render');
    const [name,setName]= useState('计数器');
    const [number,setNumber] = useState(0);
    const data ={number};
    const addClick = ()=&gt;{
        setNumber(number+1);
    };
    return (
        &lt;&gt;
            &lt;input type=&quot;text&quot; value={name} onChange={(e)=&gt;setName(e.target.value)}/&gt;
            &lt;SubCounter data={data} onClick={addClick}/&gt;
        &lt;/&gt;
    )
}
</code></pre>
<ul>
<li>更深入的优化：
<ol>
<li><strong>useCallback</strong>：接收一个内联回调函数参数和一个依赖项数组（子组件依赖父组件的状态，即子组件会使用到父组件的值） ，useCallback 会返回该回调函数的 memoized
版本，该回调函数仅在某个依赖项改变时才会更新</li>
<li><strong>useMemo</strong>：把创建函数和依赖项数组作为参数传入 <code>useMemo</code>，它仅会在某个依赖项改变时才重新计算 memoized 值。这种优化有助于避免在每次渲染时都进行高开销的计算</li>
</ol>
</li>
</ul>
<pre><code class="language-javascript">import React,{useState,memo,useMemo,useCallback} from 'react';

function SubCounter({onClick,data}){
    console.log('SubCounter render');
    return (
        &lt;button onClick={onClick}&gt;{data.number}&lt;/button&gt;
    )
}
SubCounter = memo(SubCounter);

let oldData,oldAddClick;
export  default  function Counter2(){
    console.log('Counter render');
    const [name,setName]= useState('计数器');
    const [number,setNumber] = useState(0);
    // 父组件更新时，这里的变量和函数每次都会重新创建，那么子组件接受到的属性每次都会认为是新的
    // 所以子组件也会随之更新，这时候可以用到 useMemo
    // 有没有后面的依赖项数组很重要，否则还是会重新渲染
    // 如果后面的依赖项数组没有值的话，即使父组件的 number 值改变了，子组件也不会去更新
    //const data = useMemo(()=&gt;({number}),[]);
    const data = useMemo(()=&gt;({number}),[number]);
    console.log('data===oldData ',data===oldData);
    oldData = data;
    
    // 有没有后面的依赖项数组很重要，否则还是会重新渲染
    const addClick = useCallback(()=&gt;{
        setNumber(number+1);
    },[number]);
    console.log('addClick===oldAddClick ',addClick===oldAddClick);
    oldAddClick=addClick;
    return (
        &lt;&gt;
            &lt;input type=&quot;text&quot; value={name} onChange={(e)=&gt;setName(e.target.value)}/&gt;
            &lt;SubCounter data={data} onClick={addClick}/&gt;
        &lt;/&gt;
    )
}
</code></pre>
<h3 id="46-usestate-源码中的链表实现"><a class="header" href="#46-usestate-源码中的链表实现">4.6 useState 源码中的链表实现</a></h3>
<pre><code class="language-javascript">import React from 'react';
import ReactDOM from 'react-dom';

let firstWorkInProgressHook = {memoizedState: null, next: null};
let workInProgressHook;

function useState(initState) {
    let currentHook = workInProgressHook.next ? workInProgressHook.next : {memoizedState: initState, next: null};

    function setState(newState) {
        currentHook.memoizedState = newState;
        render();
    }
   // 这就是为什么 useState 书写顺序很重要的原因
  // 假如某个 useState 没有执行，会导致指针移动出错，数据存取出错
    if (workInProgressHook.next) {
        // 这里只有组件刷新的时候，才会进入
        // 根据书写顺序来取对应的值
        // console.log(workInProgressHook);
        workInProgressHook = workInProgressHook.next;
    } else {
        // 只有在组件初始化加载时，才会进入
        // 根据书写顺序，存储对应的数据
        // 将 firstWorkInProgressHook 变成一个链表结构
        workInProgressHook.next = currentHook;
        // 将 workInProgressHook 指向 {memoizedState: initState, next: null}
        workInProgressHook = currentHook;
        // console.log(firstWorkInProgressHook);
    }
    return [currentHook.memoizedState, setState];
}

function Counter() {
    // 每次组件重新渲染的时候，这里的 useState 都会重新执行
    const [name, setName] = useState('计数器');
    const [number, setNumber] = useState(0);
    return (
        &lt;&gt;
            &lt;p&gt;{name}:{number}&lt;/p&gt;
            &lt;button onClick={() =&gt; setName('新计数器' + Date.now())}&gt;新计数器&lt;/button&gt;
            &lt;button onClick={() =&gt; setNumber(number + 1)}&gt;+&lt;/button&gt;
        &lt;/&gt;
    )
}

function render() {
    // 每次重新渲染的时候，都将 workInProgressHook 指向 firstWorkInProgressHook
    workInProgressHook = firstWorkInProgressHook;
    ReactDOM.render(&lt;Counter/&gt;, document.getElementById('root'));
}

render();
</code></pre>
<h2 id="五usereducer"><a class="header" href="#五usereducer">五、useReducer</a></h2>
<ul>
<li>useReducer 和 redux 中 reducer 很像</li>
<li>useState 内部就是靠 useReducer 来实现的</li>
<li>useState 的替代方案，它接收一个形如 (state, action) =&gt; newState 的 reducer，并返回当前的 state 以及与其配套的 dispatch 方法</li>
<li>在某些场景下，useReducer 会比 useState 更适用，例如 state 逻辑较复杂且包含多个子值，或者下一个 state 依赖于之前的 state 等</li>
</ul>
<pre><code class="language-javascript">let initialState = 0;
// 如果你希望初始状态是一个{number:0}
// 可以在第三个参数中传递一个这样的函数 ()=&gt;({number:initialState})
// 这个函数是一个惰性初始化函数，可以用来进行复杂的计算，然后返回最终的 initialState
const [state, dispatch] = useReducer(reducer, initialState, init);

const initialState = 0;
function reducer(state, action) {
  switch (action.type) {
    case 'increment':
      return {number: state.number + 1};
    case 'decrement':
      return {number: state.number - 1};
    default:
      throw new Error();
  }
}
function init(initialState){
    return {number:initialState};
}
function Counter(){
    const [state, dispatch] = useReducer(reducer, initialState,init);
    return (
        &lt;&gt;
          Count: {state.number}
          &lt;button onClick={() =&gt; dispatch({type: 'increment'})}&gt;+&lt;/button&gt;
          &lt;button onClick={() =&gt; dispatch({type: 'decrement'})}&gt;-&lt;/button&gt;
        &lt;/&gt;
    )
}
</code></pre>
<h2 id="六usecontext"><a class="header" href="#六usecontext">六、useContext</a></h2>
<ul>
<li>接收一个 context 对象（React.createContext 的返回值）并返回该 context 的当前值</li>
<li>当前的 context 值由上层组件中距离当前组件最近的 &lt;MyContext.Provider&gt; 的 value prop 决定</li>
<li>当组件上层最近的 &lt;MyContext.Provider&gt; 更新时，该 Hook 会触发重渲染，并使用最新传递给 MyContext provider 的 context value 值</li>
<li><strong>useContext(MyContext) 相当于 class 组件中的</strong> <code>static contextType = MyContext</code> 或者
<code>&lt;MyContext.Consumer&gt;</code></li>
<li><strong>useContext(MyContext) 只是让你能够读取 context 的值以及订阅 context 的变化。你仍然需要在上层组件树中使用 来为下层组件提供 context</strong></li>
</ul>
<pre><code class="language-javascript">import React,{useState,memo,useMemo,useCallback,useReducer,createContext,useContext} from 'react';
import ReactDOM from 'react-dom';

const initialState = 0;
function reducer(state=initialState,action){
    switch(action.type){
        case 'ADD':
            return {number:state.number+1};
        default:
            break; 
    }
}

const CounterContext = createContext();
// 第一种获取 CounterContext 方法：不使用 hook
function SubCounter_one(){
    return (
        &lt;CounterContext.Consumer&gt;
            {
                value=&gt;(
                    &lt;&gt;
                    &lt;p&gt;{value.state.number}&lt;/p&gt;
                    &lt;button onClick={()=&gt;value.dispatch({type:'ADD'})}&gt;+&lt;/button&gt;
                    &lt;/&gt;
                )
            }
         
        &lt;/CounterContext.Consumer&gt;
    )
}
// 第二种获取 CounterContext 方法：使用 hook ，更简洁
function SubCounter(){
    const {state, dispatch} = useContext(CounterContext);
    return (
        &lt;&gt;
            &lt;p&gt;{state.number}&lt;/p&gt;
            &lt;button onClick={()=&gt;dispatch({type:'ADD'})}&gt;+&lt;/button&gt;
        &lt;/&gt;
    )
}
/* class SubCounter extends React.Component{
    static contextTypes = CounterContext
    this.context =  {state, dispatch}
} */

function Counter(){
    const [state, dispatch] = useReducer((reducer), initialState, ()=&gt;({number:initialState}));
    return (
        &lt;CounterContext.Provider value={{state, dispatch}}&gt;
            &lt;SubCounter/&gt;
        &lt;/CounterContext.Provider&gt;
    )
}
ReactDOM.render(&lt;Counter  /&gt;, document.getElementById('root'));
</code></pre>
<h2 id="七useeffect"><a class="header" href="#七useeffect">七、useEffect</a></h2>
<ul>
<li><strong>effect（副作用）：指那些没有发生在数据向视图转换过程中的逻辑，如 <code>ajax</code> 请求、访问原生<code>dom</code> 元素、本地持久化缓存、绑定/解绑事件、添加订阅、设置定时器、记录日志等。</strong></li>
<li><strong>副作用操作可以分两类：需要清除的和不需要清除的。</strong></li>
<li>原先在函数组件内（这里指在 React 渲染阶段）改变 dom 、发送 ajax 请求以及执行其他包含副作用的操作都是不被允许的，因为这可能会产生莫名其妙的 bug 并破坏 UI 的一致性</li>
<li>useEffect 就是一个 Effect Hook，给函数组件增加了操作副作用的能力。它跟 class 组件中的 <code>componentDidMount</code>、<code>componentDidUpdate</code>
和 <code>componentWillUnmount</code> 具有相同的用途，只不过被合并成了一个 API</li>
<li><strong>useEffect 接收一个函数，该函数会在组件渲染到屏幕之后才执行，该函数有要求：要么返回一个能清除副作用的函数，要么就不返回任何内容</strong></li>
<li>与 <code>componentDidMount</code> 或 <code>componentDidUpdate</code> 不同，使用 useEffect 调度的 effect
不会阻塞浏览器更新屏幕，这让你的应用看起来响应更快。大多数情况下，effect 不需要同步地执行。在个别情况下（例如测量布局），有单独的 useLayoutEffect Hook 供你使用，其
API 与 useEffect 相同。</li>
</ul>
<h3 id="71-使用-class-组件实现修改标题"><a class="header" href="#71-使用-class-组件实现修改标题">7.1 使用 class 组件实现修改标题</a></h3>
<ul>
<li>在这个 class 中，我们需要在两个生命周期函数中编写重复的代码，这是因为很多情况下，我们希望在组件加载和更新时执行同样的操作。我们希望它在每次渲染之后执行，但 React 的 class
组件没有提供这样的方法。即使我们提取出一个方法，我们还是要在两个地方调用它。而 <strong>useEffect 会在第一次渲染之后和每次更新之后都会执行</strong></li>
</ul>
<pre><code class="language-javascript">class Counter extends React.Component{
    state = {number:0};
    add = ()=&gt;{
        this.setState({number:this.state.number+1});
    };
    componentDidMount(){
        this.changeTitle();
    }
    componentDidUpdate(){
        this.changeTitle();
    }
    changeTitle = ()=&gt;{
        document.title = `你已经点击了${this.state.number}次`;
    };
    render(){
        return (
            &lt;&gt;
              &lt;p&gt;{this.state.number}&lt;/p&gt;
              &lt;button onClick={this.add}&gt;+&lt;/button&gt;
            &lt;/&gt;
        )
    }
}
</code></pre>
<h3 id="72-使用-useeffect-来实现修改标题"><a class="header" href="#72-使用-useeffect-来实现修改标题">7.2 使用 useEffect 来实现修改标题</a></h3>
<ul>
<li>每次我们重新渲染，都会生成新的 effect，替换掉之前的。某种意义上讲，effect 更像是渲染结果的一部分 —— 每个 effect 属于一次特定的渲染。</li>
</ul>
<pre><code class="language-javascript">import React,{Component,useState,useEffect} from 'react';
import ReactDOM from 'react-dom';
function Counter(){
    const [number,setNumber] = useState(0);
    // useEffect里面的这个函数会在第一次渲染之后和更新完成后执行
    // 相当于 componentDidMount 和 componentDidUpdate:
    useEffect(() =&gt; {
        document.title = `你点击了${number}次`;
    });
    return (
        &lt;&gt;
            &lt;p&gt;{number}&lt;/p&gt;
            &lt;button onClick={()=&gt;setNumber(number+1)}&gt;+&lt;/button&gt;
        &lt;/&gt;
    )
}
ReactDOM.render(&lt;Counter /&gt;, document.getElementById('root'));
</code></pre>
<h3 id="73-清除副作用"><a class="header" href="#73-清除副作用">7.3 清除副作用</a></h3>
<ul>
<li><strong>副作用函数还可以通过返回一个函数来指定如何清除副作用，为防止内存泄漏，清除函数会在组件卸载前执行。如果组件多次渲染，则在执行下一个 effect 之前，上一个 effect 就已被清除。</strong></li>
</ul>
<pre><code class="language-javascript">function Counter(){
    let [number,setNumber] = useState(0);
    let [text,setText] = useState('');
    // 相当于componentDidMount 和 componentDidUpdate
    useEffect(()=&gt;{
        console.log('开启一个新的定时器')
        let $timer = setInterval(()=&gt;{
            setNumber(number=&gt;number+1);
        },1000);
        // useEffect 如果返回一个函数的话，该函数会在组件卸载和更新时调用
        // useEffect 在执行副作用函数之前，会先调用上一次返回的函数
        // 如果要清除副作用，要么返回一个清除副作用的函数
       /*  return ()=&gt;{
            console.log('destroy effect');
            clearInterval($timer);
        } */
    });
    // },[]);//要么在这里传入一个空的依赖项数组，这样就不会去重复执行
    return (
        &lt;&gt;
          &lt;input value={text} onChange={(event)=&gt;setText(event.target.value)}/&gt;
          &lt;p&gt;{number}&lt;/p&gt;
          &lt;button&gt;+&lt;/button&gt;
        &lt;/&gt;
    )
}
</code></pre>
<h3 id="74-跳过-effect-进行性能优化"><a class="header" href="#74-跳过-effect-进行性能优化">7.4 跳过 effect 进行性能优化</a></h3>
<ul>
<li>依赖项数组控制着 useEffect 的执行</li>
<li>如果某些特定值在两次重渲染之间没有发生变化，你可以通知 React 跳过对 effect 的调用，只要传递数组作为 useEffect 的第二个可选参数即可</li>
<li>如果想执行只运行一次的 effect（仅在组件挂载和卸载时执行），可以传递一个空数组（[]）作为第二个参数。这就告诉 React 你的 effect 不依赖于 props 或 state
中的任何值，所以它永远都不需要重复执行</li>
<li>推荐启用
<a href="https://www.npmjs.com/package/eslint-plugin-react-hooks#installation">eslint-plugin-react-hooks</a>
中的 <a href="https://github.com/facebook/react/issues/14920">exhaustive-deps</a> 规则。此规则会在添加错误依赖时发出警告并给出修复建议。</li>
</ul>
<pre><code class="language-javascript">function Counter(){
    let [number,setNumber] = useState(0);
    let [text,setText] = useState('');
    // 相当于componentDidMount 和 componentDidUpdate
    useEffect(()=&gt;{
        console.log('useEffect');
        let $timer = setInterval(()=&gt;{
            setNumber(number=&gt;number+1);
        },1000);
    },[text]);// 数组表示 effect 依赖的变量，只有当这个变量发生改变之后才会重新执行 efffect 函数
    return (
        &lt;&gt;
          &lt;input value={text} onChange={(event)=&gt;setText(event.target.value)}/&gt;
          &lt;p&gt;{number}&lt;/p&gt;
          &lt;button&gt;+&lt;/button&gt;
        &lt;/&gt;
    )
}
</code></pre>
<h3 id="75-使用多个-effect-实现关注点分离"><a class="header" href="#75-使用多个-effect-实现关注点分离">7.5 使用多个 Effect 实现关注点分离</a></h3>
<ul>
<li>使用 Hook 其中一个目的就是要解决 class 中生命周期函数经常包含不相关的逻辑，但又把相关逻辑分离到了几个不同方法中的问题。</li>
</ul>
<pre><code class="language-javascript">// 类组件版
class FriendStatusWithCounter extends React.Component {
  constructor(props) {
    super(props);
    this.state = { count: 0, isOnline: null };
    this.handleStatusChange = this.handleStatusChange.bind(this);
  }

  componentDidMount() {
    document.title = `You clicked ${this.state.count} times`;
    ChatAPI.subscribeToFriendStatus(
      this.props.friend.id,
      this.handleStatusChange
    );
  }

  componentDidUpdate() {
    document.title = `You clicked ${this.state.count} times`;
  }

  componentWillUnmount() {
    ChatAPI.unsubscribeFromFriendStatus(
      this.props.friend.id,
      this.handleStatusChange
    );
  }

  handleStatusChange(status) {
    this.setState({
      isOnline: status.isOnline
    });
  }
  // ...
</code></pre>
<ul>
<li>可以发现设置 <code>document.title</code> 的逻辑是如何被分割到 <code>componentDidMount</code> 和 <code>componentDidUpdate</code> 中的，订阅逻辑又是如何被分割到
<code>componentDidMount</code> 和 <code>componentWillUnmount</code> 中的。而且 <code>componentDidMount</code>
中同时包含了两个不同功能的代码。这样会使得生命周期函数很混乱。</li>
<li><strong>Hook 允许我们按照代码的用途分离他们，</strong> 而不是像生命周期函数那样。React 将按照 effect 声明的顺序依次调用组件中的 每一个 effect。</li>
</ul>
<pre><code class="language-javascript">// Hooks 版
function FriendStatusWithCounter(props) {
  const [count, setCount] = useState(0);
  useEffect(() =&gt; {
    document.title = `You clicked ${count} times`;
  });

  const [isOnline, setIsOnline] = useState(null);
  useEffect(() =&gt; {
    function handleStatusChange(status) {
      setIsOnline(status.isOnline);
    }

    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);
    return () =&gt; {
      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);
    };
  });
  // ...
}
</code></pre>
<h2 id="八uselayouteffect"><a class="header" href="#八uselayouteffect">八、useLayoutEffect</a></h2>
<p><img src="React/./images/useLayoutEffect.png" alt="img" /></p>
<ul>
<li><strong>useEffect 在全部渲染完毕后才会执行</strong></li>
<li><strong>useLayoutEffect 会在 浏览器 layout 之后，painting 之前执行</strong></li>
<li>其函数签名与 useEffect 相同，但它会在所有的 DOM 变更之后<strong>同步</strong>调用 effect</li>
<li><strong>可以使用它来读取 DOM 布局并同步触发重渲染</strong></li>
<li>在浏览器执行绘制之前 useLayoutEffect 内部的更新计划将被<strong>同步</strong>刷新</li>
<li><strong>尽可能使用标准的 useEffect 以避免阻塞视图更新</strong></li>
</ul>
<pre><code class="language-javascript">function LayoutEffect() {
    const [color, setColor] = useState('red');
    useLayoutEffect(() =&gt; {
        alert(color);
    });
    useEffect(() =&gt; {
        console.log('color', color);
    });
    return (
        &lt;&gt;
            &lt;div id=&quot;myDiv&quot; style={{ background: color }}&gt;颜色&lt;/div&gt;
            &lt;button onClick={() =&gt; setColor('red')}&gt;红&lt;/button&gt;
            &lt;button onClick={() =&gt; setColor('yellow')}&gt;黄&lt;/button&gt;
            &lt;button onClick={() =&gt; setColor('blue')}&gt;蓝&lt;/button&gt;
        &lt;/&gt;
    );
}
</code></pre>
<h2 id="九useref--useimperativehandle"><a class="header" href="#九useref--useimperativehandle">九、useRef &amp; useImperativeHandle</a></h2>
<h3 id="81-useref"><a class="header" href="#81-useref">8.1 useRef</a></h3>
<ul>
<li>类组件、React 元素用 React.createRef，函数组件使用 useRef</li>
<li>useRef 返回一个可变的 ref 对象，其 <code>current</code> 属性被初始化为传入的参数（initialValue）</li>
</ul>
<pre><code class="language-javascript">const refContainer = useRef(initialValue);
</code></pre>
<ul>
<li><strong>useRef 返回的 ref 对象在组件的整个生命周期内保持不变，也就是说每次重新渲染函数组件时，返回的ref 对象都是同一个（使用 React.createRef
，每次重新渲染组件都会重新创建 ref）</strong></li>
</ul>
<pre><code class="language-javascript">import React, { useState, useEffect, useRef } from 'react';
import ReactDOM from 'react-dom';
function Parent() {
    let [number, setNumber] = useState(0);
    return (
        &lt;&gt;
            &lt;Child /&gt;
            &lt;button onClick={() =&gt; setNumber({ number: number + 1 })}&gt;+&lt;/button&gt;
        &lt;/&gt;
    )
}
let input;
function Child() {
    const inputRef = useRef();
    console.log('input===inputRef', input === inputRef);
    input = inputRef;
    function getFocus() {
        inputRef.current.focus();
    }
    return (
        &lt;&gt;
            &lt;input type=&quot;text&quot; ref={inputRef} /&gt;
            &lt;button onClick={getFocus}&gt;获得焦点&lt;/button&gt;
        &lt;/&gt;
    )
}
ReactDOM.render(&lt;Parent /&gt;, document.getElementById('root'));
</code></pre>
<h3 id="82-forwardref"><a class="header" href="#82-forwardref">8.2 forwardRef</a></h3>
<ul>
<li><strong>因为函数组件没有实例，所以函数组件无法像类组件一样可以接收 ref 属性</strong></li>
</ul>
<pre><code class="language-javascript">function Parent() {
    return (
        &lt;&gt;
         // &lt;Child ref={xxx} /&gt; 这样是不行的
            &lt;Child /&gt;
            &lt;button&gt;+&lt;/button&gt;
        &lt;/&gt;
    )
}
</code></pre>
<ul>
<li><strong>forwardRef 可以在父组件中操作子组件的 ref 对象</strong></li>
<li><strong>forwardRef 可以将父组件中的 ref 对象转发到子组件中的 dom 元素上</strong></li>
<li><strong>子组件接受 props 和 ref 作为参数</strong></li>
</ul>
<pre><code class="language-javascript">function Child(props,ref){
  return (
    &lt;input type=&quot;text&quot; ref={ref}/&gt;
  )
}
Child = React.forwardRef(Child);
function Parent(){
  let [number,setNumber] = useState(0); 
  // 在使用类组件的时候，创建 ref 返回一个对象，该对象的 current 属性值为空
  // 只有当它被赋给某个元素的 ref 属性时，才会有值
  // 所以父组件（类组件）创建一个 ref 对象，然后传递给子组件（类组件），子组件内部有元素使用了
  // 那么父组件就可以操作子组件中的某个元素
  // 但是函数组件无法接收 ref 属性 &lt;Child ref={xxx} /&gt; 这样是不行的
  // 所以就需要用到 forwardRef 进行转发
  const inputRef = useRef();//{current:''}
  function getFocus(){
    inputRef.current.value = 'focus';
    inputRef.current.focus();
  }
  return (
      &lt;&gt;
        &lt;Child ref={inputRef}/&gt;
        &lt;button onClick={()=&gt;setNumber({number:number+1})}&gt;+&lt;/button&gt;
        &lt;button onClick={getFocus}&gt;获得焦点&lt;/button&gt;
      &lt;/&gt;
  )
}
</code></pre>
<h3 id="83-useimperativehandle"><a class="header" href="#83-useimperativehandle">8.3 useImperativeHandle</a></h3>
<ul>
<li><code>useImperativeHandle</code>可以让你在使用 ref 时，自定义暴露给父组件的实例值，不能让父组件想干嘛就干嘛</li>
<li><strong>在大多数情况下，应当避免使用 ref 这样的命令式代码。useImperativeHandle 应当与 forwardRef 一起使用</strong></li>
<li><strong>父组件可以使用操作子组件中的多个 ref</strong></li>
</ul>
<pre><code class="language-javascript">import React,{useState,useEffect,createRef,useRef,forwardRef,useImperativeHandle} from 'react';

function Child(props,parentRef){
    // 子组件内部自己创建 ref 
    let focusRef = useRef();
    let inputRef = useRef();
    useImperativeHandle(parentRef,()=&gt;(
      // 这个函数会返回一个对象
      // 该对象会作为父组件 current 属性的值
      // 通过这种方式，父组件可以使用操作子组件中的多个 ref
        return {
            focusRef,
            inputRef,
            name:'计数器',
            focus(){
                focusRef.current.focus();
            },
            changeText(text){
                inputRef.current.value = text;
            }
        }
    });
    return (
        &lt;&gt;
            &lt;input ref={focusRef}/&gt;
            &lt;input ref={inputRef}/&gt;
        &lt;/&gt;
    )

}
Child = forwardRef(Child);
function Parent(){
  const parentRef = useRef();//{current:''}
  function getFocus(){
    parentRef.current.focus();
    // 因为子组件中没有定义这个属性，实现了保护，所以这里的代码无效
    parentRef.current.addNumber(666);
    parentRef.current.changeText('&lt;script&gt;alert(1)&lt;/script&gt;');
    console.log(parentRef.current.name);
  }
  return (
      &lt;&gt;
        &lt;ForwardChild ref={parentRef}/&gt;
        &lt;button onClick={getFocus}&gt;获得焦点&lt;/button&gt;
      &lt;/&gt;
  )
}
</code></pre>
<h2 id="十自定义-hook"><a class="header" href="#十自定义-hook">十、自定义 Hook</a></h2>
<ul>
<li>自定义 Hook 更像是一种约定，而不是一种功能。如果函数的名字以 use 开头，并且调用了其他的 Hook，则就称其为一个自定义 Hook</li>
<li>有时候我们会想要在组件之间重用一些状态逻辑，之前要么用 render props ，要么用高阶组件，要么使用 redux</li>
<li>自定义 Hook 可以让你在不增加组件的情况下达到同样的目的</li>
<li><strong>Hook 是一种复用状态逻辑的方式，它不复用 state 本身</strong></li>
<li><strong>事实上 Hook 的每次调用都有一个完全独立的 state</strong></li>
</ul>
<pre><code class="language-javascript">import React, { useLayoutEffect, useEffect, useState } from 'react';
import ReactDOM from 'react-dom';

function useNumber(){
  let [number,setNumber] = useState(0);
  useEffect(()=&gt;{
    setInterval(()=&gt;{
        setNumber(number=&gt;number+1);
    },1000);
  },[]);
  return [number,setNumber];
}
// 每个组件调用同一个 hook，只是复用 hook 的状态逻辑，并不会共用一个状态
function Counter1(){
    let [number,setNumber] = useNumber();
    return (
        &lt;div&gt;&lt;button onClick={()=&gt;{
            setNumber(number+1)
        }}&gt;{number}&lt;/button&gt;&lt;/div&gt;
    )
}
function Counter2(){
    let [number,setNumber] = useNumber();
    return (
        &lt;div&gt;&lt;button  onClick={()=&gt;{
            setNumber(number+1)
        }}&gt;{number}&lt;/button&gt;&lt;/div&gt;
    )
}
ReactDOM.render(&lt;&gt;&lt;Counter1 /&gt;&lt;Counter2 /&gt;&lt;/&gt;, document.getElementById('root'));
</code></pre>
<h2 id="十一常见问题"><a class="header" href="#十一常见问题">十一、常见问题</a></h2>
<h3 id="1-使用-a-hrefhttpswwwnpmjscompackageeslint-plugin-react-hookseslint-plugin-react-hooksa-来检查代码错误给出提示"><a class="header" href="#1-使用-a-hrefhttpswwwnpmjscompackageeslint-plugin-react-hookseslint-plugin-react-hooksa-来检查代码错误给出提示">1. 使用 <a href="https://www.npmjs.com/package/eslint-plugin-react-hooks">eslint-plugin-react-hooks</a> 来检查代码错误，给出提示</a></h3>
<pre><code class="language-json">{
  &quot;plugins&quot;: [&quot;react-hooks&quot;],
  // ...
  &quot;rules&quot;: {
    &quot;react-hooks/rules-of-hooks&quot;: 'error',// 检查 Hook 的规则
    &quot;react-hooks/exhaustive-deps&quot;: 'warn' // 检查 effect 的依赖
  }
}
</code></pre>
<h3 id="2为什么每次更新的时候都要运行-effect"><a class="header" href="#2为什么每次更新的时候都要运行-effect">2.为什么每次更新的时候都要运行 Effect</a></h3>
<p><a href="https://react.docschina.org/docs/hooks-effect.html#explanation-why-effects-run-on-each-update">react.docschina.org/docs/hooks-…</a></p>
<h3 id="3为什么必须在组件的顶层使用-hook--在单个组件中使用多个-state-hook-或-effect-hook那么-react-怎么知道哪个-state-对应哪个-usestate"><a class="header" href="#3为什么必须在组件的顶层使用-hook--在单个组件中使用多个-state-hook-或-effect-hook那么-react-怎么知道哪个-state-对应哪个-usestate">3.为什么必须在组件的顶层使用 Hook &amp; 在单个组件中使用多个 State Hook 或 Effect Hook，那么 React 怎么知道哪个 state 对应哪个 useState？</a></h3>
<ul>
<li><strong>React 依赖于 Hook 的调用顺序</strong>，如果能确保 Hook 在每一次渲染中都按照同样的顺序被调用。那么React 能够在多次的 <code>useState</code> 和 <code>useEffect</code>
调用之间保持 hook 状态的正确性</li>
</ul>
<pre><code class="language-javascript">function Form() {
  // 1. Use the name state variable
  const [name, setName] = useState('Mary');

  // 2. Use an effect for persisting the form
  useEffect(function persistForm() {
    localStorage.setItem('formData', name);
  });

  // 3. Use the surname state variable
  const [surname, setSurname] = useState('Poppins');

  // 4. Use an effect for updating the title
  useEffect(function updateTitle() {
    document.title = name + ' ' + surname;
  });

  // ...
}

// ------------
// 首次渲染
// ------------
useState('Mary')           // 1. 使用 'Mary' 初始化变量名为 name 的 state
useEffect(persistForm)     // 2. 添加 effect 以保存 form 操作
useState('Poppins')        // 3. 使用 'Poppins' 初始化变量名为 surname 的 state
useEffect(updateTitle)     // 4. 添加 effect 以更新标题
// -------------
// 二次渲染
// -------------
useState('Mary')           // 1. 读取变量名为 name 的 state（参数被忽略）
useEffect(persistForm)     // 2. 替换保存 form 的 effect
useState('Poppins')        // 3. 读取变量名为 surname 的 state（参数被忽略）
useEffect(updateTitle)     // 4. 替换更新标题的 effect
// ...
</code></pre>
<p><strong>只要 Hook 的调用顺序在多次渲染之间保持一致，React 就能正确地将内部 state 和对应的 Hook 进行关联</strong>。但如果我们将一个 Hook (例如 <code>persistForm</code>
effect) 调用放到一个条件语句中会发生什么呢？</p>
<pre><code>// 🔴 在条件语句中使用 Hook 违反第一条规则
  if (name !== '') {
    useEffect(function persistForm() {
      localStorage.setItem('formData', name);
    });
  }
</code></pre>
<p>在第一次渲染中 <code>name !== ''</code> 这个条件值为 <code>true</code>，所以我们会执行这个 Hook。但是下一次渲染时我们可能清空了表单，表达式值变为 <code>false</code>。此时的渲染会跳过该
Hook，Hook 的调用顺序发生了改变：</p>
<pre><code class="language-javascript">useState('Mary')           // 1. 读取变量名为 name 的 state（参数被忽略）
// useEffect(persistForm)  // 🔴 此 Hook 被忽略！
useState('Poppins')        // 🔴 2 （之前为 3）。读取变量名为 surname 的 state 失败
useEffect(updateTitle)     // 🔴 3 （之前为 4）。替换更新标题的 effect 失败
</code></pre>
<p>React 不知道第二个 <code>useState</code> 的 Hook 应该返回什么。React 会以为在该组件中第二个 Hook 的调用像上次的渲染一样，对应得是 <code>persistForm</code> 的
effect，但并非如此。从这里开始，后面的 Hook 调用都被提前执行，导致 bug 的产生。</p>
<p>如果我们想要有条件地执行一个 effect，可以将判断放到 Hook 的_内部_：</p>
<pre><code class="language-javascript">useEffect(function persistForm() {
    // 👍 将条件判断放置在 effect 中
    if (name !== '') {
      localStorage.setItem('formData', name);
    }
  });
</code></pre>
<h3 id="4-自定义-hook-必须以-use-开头吗"><a class="header" href="#4-自定义-hook-必须以-use-开头吗">4. <strong>自定义 Hook 必须以 <code>use</code> 开头吗？</strong></a></h3>
<p>必须如此。这个约定非常重要。不遵循的话，由于无法判断某个函数是否包含对其内部 Hook 的调用，React 将无法自动检查你的 Hook 是否违反了
<a href="https://react.docschina.org/docs/hooks-rules.html">Hook 的规则</a>。</p>
<h3 id="5-在两个组件中使用相同的-hook-会共享-state-吗"><a class="header" href="#5-在两个组件中使用相同的-hook-会共享-state-吗">5. <strong>在两个组件中使用相同的 Hook 会共享 state 吗？</strong></a></h3>
<p>不会。自定义 Hook 是一种重用_状态逻辑_的机制(例如设置为订阅并存储当前值)，所以每次使用自定义 Hook 时，其中的所有 state 和副作用都是完全隔离的。</p>
<h3 id="6-在一个组件中多次调用-usestate-或者-useeffect每次调用-hook它都会获取独立的-state是完全独立的"><a class="header" href="#6-在一个组件中多次调用-usestate-或者-useeffect每次调用-hook它都会获取独立的-state是完全独立的">6. 在一个组件中多次调用 <code>useState</code> 或者 <code>useEffect</code>，每次调用 Hook，它都会获取独立的 state，是完全独立的</a></h3>
<h3 id="7-当组件拥有多个-state-时应该把多个-state-合并成一个-state-还是把-state-切分成多个-state-变量"><a class="header" href="#7-当组件拥有多个-state-时应该把多个-state-合并成一个-state-还是把-state-切分成多个-state-变量">7. 当组件拥有多个 state 时，应该把多个 state 合并成一个 state ，还是把 state 切分成多个 state 变量？</a></h3>
<p><a href="https://react.docschina.org/docs/hooks-faq.html#should-i-use-one-or-many-state-variables">react.docschina.org/docs/hooks-…</a></p>
<ul>
<li>要么把所有 state 都放在同一个 <code>useState</code> 调用中，要么每一个字段都对应一个 <code>useState</code> 调用，这两方式都能跑通。</li>
<li>当你在这<strong>两个极端</strong>之间找到平衡，然后把<strong>相关 state</strong> <strong>组合到几个独立的 state 变量</strong>时，组件就会更加的可读。如果 state 的逻辑开始变得复杂，我们推荐用
<code>useReducer</code> 来管理它，或使用自定义 Hook。</li>
</ul>
<h3 id="8-可以只在更新时运行-effect-吗"><a class="header" href="#8-可以只在更新时运行-effect-吗">8. 可以只在更新时运行 effect 吗？</a></h3>
<p>这是个比较罕见的使用场景。如果你需要的话，你可以
<a href="https://react.docschina.org/docs/hooks-faq.html#is-there-something-like-instance-variables">使用一个可变的 ref</a>
手动存储一个布尔值来表示是首次渲染还是后续渲染，然后在你的 effect 中检查这个标识。（如果你发现自己经常在这么做，你可以为之创建一个自定义 Hook。）</p>
<h3 id="9-在-useeffect-中调用用函数时要把该函数在-useeffect-中申明不能放到外部申明然后再在-useeffect-中调用"><a class="header" href="#9-在-useeffect-中调用用函数时要把该函数在-useeffect-中申明不能放到外部申明然后再在-useeffect-中调用">9. 在 useEffect 中调用用函数时，要把该函数在 useEffect 中申明，不能放到外部申明，然后再在 useEffect 中调用</a></h3>
<p><a href="https://react.docschina.org/docs/hooks-faq.html#is-it-safe-to-omit-functions-from-the-list-of-dependencies">react.docschina.org/docs/hooks-…</a></p>
<pre><code class="language-javascript">function Example({ someProp }) {
  function doSomething() {
    console.log(someProp);
  }

  useEffect(() =&gt; {
    doSomething();
  }, []); // 🔴 这样不安全（它调用的 `doSomething` 函数使用了 `someProp`）
}
</code></pre>
<p>要记住 effect 外部的函数使用了哪些 props 和 state 很难。这也是为什么 <strong>通常你会想要在 effect 内部 去声明它所需要的函数。</strong> 这样就能容易的看出那个 effect
依赖了组件作用域中的哪些值：</p>
<pre><code class="language-javascript">function Example({ someProp }) {
  useEffect(() =&gt; {
    function doSomething() {
      console.log(someProp);
    }

    doSomething();
  }, [someProp]); // ✅ 安全（我们的 effect 仅用到了 `someProp`）
}
</code></pre>
<p><strong>只有</strong> 当函数（以及它所调用的函数）不引用 props、state 以及由它们衍生而来的值时，你才能放心地把它们从依赖列表中省略。下面这个案例有一个 Bug：</p>
<pre><code class="language-javascript">function ProductPage({ productId }) {
  const [product, setProduct] = useState(null);
  async function fetchProduct() {
    const response = await fetch('http://myapi/product' + productId); // 使用了 productId prop
    const json = await response.json();
    setProduct(json);
  }
  useEffect(() =&gt; {
    fetchProduct();
  }, []); // 🔴 这样是无效的，因为 `fetchProduct` 使用了 `productId`
  // ...
}
</code></pre>
<p><strong>推荐的修复方案是把那个函数移动到你的 effect 内部</strong>。这样就能很容易的看出来你的 effect 使用了哪些 props 和 state，并确保它们都被声明了：</p>
<pre><code class="language-javascript">function ProductPage({ productId }) {
  const [product, setProduct] = useState(null);
  useEffect(() =&gt; {
    // 把这个函数移动到 effect 内部后，我们可以清楚地看到它用到的值。
    async function fetchProduct() {
      const response = await fetch('http://myapi/product' + productId);
      const json = await response.json();
      setProduct(json);
    }
    fetchProduct();
  }, [productId]); // ✅ 有效，因为我们的 effect 只用到了 productId
  // ...
}
</code></pre>
<h3 id="10-如何在-hooks-中优雅的-fetch-data"><a class="header" href="#10-如何在-hooks-中优雅的-fetch-data">10. 如何在 Hooks 中优雅的 Fetch Data</a></h3>
<p><a href="https://www.robinwieruch.de/react-hooks-fetch-data/">www.robinwieruch.de/react-hooks…</a></p>
<p><a href="https://codesandbox.io/s/jvvkoo8pq3">codesandbox.io/s/jvvkoo8pq…</a></p>
<pre><code class="language-javascript">import React, { useState, useEffect } from 'react';
import axios from 'axios';
function App() {
  const [data, setData] = useState({ hits: [] });
  // 注意 async 的位置
  // 这种写法，虽然可以运行，但是会发出警告
  // 每个带有 async 修饰的函数都返回一个隐含的 promise
  // 但是 useEffect 函数有要求：要么返回清除副作用函数，要么就不返回任何内容
  useEffect(async () =&gt; {
    const result = await axios(
      'https://hn.algolia.com/api/v1/search?query=redux',
    );
    setData(result.data);
  }, []);
  return (
    &lt;ul&gt;
      {data.hits.map(item =&gt; (
        &lt;li key={item.objectID}&gt;
          &lt;a href={item.url}&gt;{item.title}&lt;/a&gt;
        &lt;/li&gt;
      ))}
    &lt;/ul&gt;
  );
}
export default App;

import React, { useState, useEffect } from 'react';
import axios from 'axios';
function App() {
  const [data, setData] = useState({ hits: [] });
  useEffect(() =&gt; {
    // 更优雅的方式
    const fetchData = async () =&gt; {
      const result = await axios(
        'https://hn.algolia.com/api/v1/search?query=redux',
      );
      setData(result.data);
    };
    fetchData();
  }, []);
  return (
    &lt;ul&gt;
      {data.hits.map(item =&gt; (
        &lt;li key={item.objectID}&gt;
          &lt;a href={item.url}&gt;{item.title}&lt;/a&gt;
        &lt;/li&gt;
      ))}
    &lt;/ul&gt;
  );
}
export default App;
</code></pre>
<h3 id="11-不要过度依赖-usememo"><a class="header" href="#11-不要过度依赖-usememo">11. 不要过度依赖 useMemo</a></h3>
<ul>
<li>
<p><code>useMemo</code> 本身也有开销。<code>useMemo</code> 会「记住」一些值，同时在后续 render
时，将依赖数组中的值取出来和上一次记录的值进行比较，如果不相等才会重新执行回调函数，否则直接返回「记住」的值。这个过程本身就会消耗一定的内存和计算资源。因此，过度使用 <code>useMemo</code>
可能会影响程序的性能。</p>
</li>
<li>
<p>在使用<code>useMemo</code> 前，应该先思考三个问题：</p>
<ul>
<li><strong>传递给 <code>useMemo</code> 的函数开销大不大？</strong> 有些计算开销很大，我们就需要「记住」它的返回值，避免每次 render
都去重新计算。如果你执行的操作开销不大，那么就不需要记住返回值。否则，使用 <code>useMemo</code> 本身的开销就可能超过重新计算这个值的开销。因此，对于一些简单的 JS 运算来说，我们不需要使用
<code>useMemo</code> 来「记住」它的返回值。</li>
<li><strong>返回的值是原始值吗？</strong> 如果计算出来的是<strong>基本类型</strong>的值（<code>string</code>、 <code>boolean</code> 、<code>null</code>、<code>undefined</code>
、<code>number</code>、<code>symbol</code>），那么每次比较都是相等的，下游组件就不会重新渲染；如果计算出来的是<strong>复杂类型</strong>的值（<code>object</code>、<code>array</code>），哪怕值不变，但是地址会发生变化，导致下游组件重新渲染。所以我们也需要「记住」这个值。</li>
<li><strong>在编写自定义 Hook 时，返回值一定要保持引用的一致性。</strong> 因为你无法确定外部要如何使用它的返回值。如果返回值被用做其他 Hook 的依赖，并且每次 re-render
时引用不一致（当值相等的情况），就可能会产生 bug。所以如果自定义 Hook 中暴露出来的值是 object、array、函数等，都应该使用 <code>useMemo</code>
。以确保当值相同时，引用不发生变化。</li>
</ul>
</li>
</ul>
<h3 id="12-useeffect-不能接收-async-作为回调函数"><a class="header" href="#12-useeffect-不能接收-async-作为回调函数">12. useEffect 不能接收 async 作为回调函数</a></h3>
<p>useEffect 接收的函数，要么返回一个能清除副作用的函数，要么就不返回任何内容。而 async 返回的是 promise。</p>
<p><a href="https://www.robinwieruch.de/react-hooks-fetch-data">www.robinwieruch.de/react-hooks…</a></p>
<p><img src="React/./images/useEffect_async.png" alt="image.png" /></p>
<h2 id="十二项目实战"><a class="header" href="#十二项目实战">十二、项目实战</a></h2>
<p><a href="https://github.com/yjdjiayou/react-hooks-qunar-demo"><strong>React Hooks 项目</strong></a></p>
<h2 id="十三参考"><a class="header" href="#十三参考">十三、参考</a></h2>
<p><strong><a href="https://react.docschina.org/docs/hooks-faq.html">官方提供的问题列表</a></strong></p>
<p><strong><a href="https://reactjs.org/docs/hooks-rules.html#explanation">React 使用规则</a></strong></p>
<p><strong><a href="https://juejin.im/post/6844903958968795149">React Hooks 你真的用对了吗？</a></strong></p>
<p><strong><a href="https://github.com/streamich/react-use">大量自定义 hooks 的</a>
<a href="https://github.com/streamich/react-use">仓库</a></strong></p>
<p><strong><a href="https://juejin.im/post/6844903861434449933">从 Preact 中了解 React 组件和 hooks 基本原理表</a></strong></p>
<p><strong><a href="https://juejin.im/post/6844903918577664007">2019年了，整理了N个实用案例帮你快速迁移到React Hooks</a></strong></p>
<h2 id="十四推荐阅读"><a class="header" href="#十四推荐阅读">十四、推荐阅读</a></h2>
<p><a href="https://juejin.im/post/6844904021233238024"><strong>你真的了解 React 生命周期吗</strong></a></p>
<p><strong><a href="https://juejin.im/post/6844904017487724557">React SSR 详解【近 1W 字】+ 2个项目实战</a></strong></p>
<p><strong><a href="https://juejin.im/post/6844903966849892359">从 0 到 1 实现一款简易版 Webpack</a></strong></p>
<p><strong><a href="https://juejin.im/post/6844904023791796237">Webpack 设置环境变量的误区</a></strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vue2x-响应式原理"><a class="header" href="#vue2x-响应式原理">Vue2.x 响应式原理</a></h1>
<p>众所周知，Vue2.x是基于Object.defineProperty()来实现响应式的。</p>
<p>那么，defineProperty是啥呢。</p>
<p>先附上MDN的连接<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">Object.defineProperty()</a></p>
<h2 id="objectdefineproperty"><a class="header" href="#objectdefineproperty">Object.defineProperty</a></h2>
<p>引用MDN的原话：</p>
<blockquote>
<p><code>Object.defineProperty()</code>方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。</p>
</blockquote>
<p>那么重点有两个：</p>
<ol>
<li>对象</li>
<li>定义新属性或修改现有属性</li>
</ol>
<p>那么什么叫<code>定义新属性或修改现有属性</code>呢？</p>
<p>我们来看看另外一个概念<code>属性描述符</code></p>
<h2 id="属性描述符"><a class="header" href="#属性描述符">属性描述符</a></h2>
<h3 id="描述符的介绍"><a class="header" href="#描述符的介绍">描述符的介绍</a></h3>
<p>对象里目前存在的属性描述符有两种主要形式：</p>
<ul>
<li>数据描述符：具有值的属性，该值可以是可写的，也可以是不可写的。</li>
<li>存取描述符：由getter和setter函数描述的属性。</li>
</ul>
<p>一个描述符只可能是二者之一，不可能同时是两者。即二选一。</p>
<p>上述两种描述符都是对象，共享以下可选键值。（默认值是指在使用 <code>Object.defineProperty()</code> 定义属性时的默认值）</p>
<table><thead><tr><th>键值</th><th>描述</th><th>默认值</th></tr></thead><tbody>
<tr><td>configurable</td><td>当且仅当该属性的 <code>configurable</code> 键值为 <code>true</code> 时，该属性的描述符才能够被改变，同时该属性也能从对应的对象上被删除。</td><td>false</td></tr>
<tr><td>enumerable</td><td>当且仅当该属性的 <code>enumerable</code> 键值为 <code>true</code> 时，该属性才会出现在对象的枚举属性中。</td><td>false</td></tr>
<tr><td>value</td><td>该属性对应的值。可以是任何有效的 JavaScript 值（数值，对象，函数等）。</td><td>undefined</td></tr>
<tr><td>writable</td><td>当且仅当该属性的 <code>writable</code> 键值为 <code>true</code> 时，属性的值，也就是上面的 <code>value</code>，才能被赋值。</td><td>false</td></tr>
</tbody></table>
<blockquote>
<p>因为<code>enumerable</code>属性默认是false，所以通过<code>Object.defineProperty()</code>定义的属性都是不会被<code>for...in</code>和<code>Object.keys</code>访问到。</p>
</blockquote>
<p>以下是存取描述符独有的：</p>
<table><thead><tr><th>键值</th><th>描述</th><th>默认值</th></tr></thead><tbody>
<tr><td>get</td><td>属性的 getter 函数，如果没有 getter，则为 <code>undefined</code>。当访问该属性时，会调用此函数。执行时不传入任何参数，但是会传入 <code>this</code> 对象（由于继承关系，这里的<code>this</code>并不一定是定义该属性的对象）。该函数的返回值会被用作属性的值。</td><td>undefined</td></tr>
<tr><td>get</td><td>属性的 setter 函数，如果没有 setter，则为 <code>undefined</code>。当属性值被修改时，会调用此函数。该方法接受一个参数（也就是被赋予的新值），会传入赋值时的 <code>this</code> 对象。</td><td>undefined</td></tr>
</tbody></table>
<p>可以看到，跟值相关的，默认值都是undefined。跟<code>able</code>相关的，默认值都是false。</p>
<h3 id="怎么区分描述符呢"><a class="header" href="#怎么区分描述符呢">怎么区分描述符呢？</a></h3>
<table><thead><tr><th align="center"></th><th align="center">configurable</th><th align="center">enumerable</th><th align="center">value</th><th align="center">writable</th><th align="center">get</th><th align="center">set</th></tr></thead><tbody>
<tr><td align="center">数据描述符</td><td align="center">√</td><td align="center">√</td><td align="center">√</td><td align="center">√</td><td align="center">×</td><td align="center">×</td></tr>
<tr><td align="center">存取描述符</td><td align="center">√</td><td align="center">√</td><td align="center">×</td><td align="center">×</td><td align="center">√</td><td align="center">√</td></tr>
</tbody></table>
<p>如果一个描述符不具有 <code>value</code>、<code>writable</code>、<code>get</code> 和 <code>set</code> 中的任意一个键，那么它将被认为是一个数据描述符。如果一个描述符同时拥有 <code>value</code> 或 <code>writable</code>
和 <code>get</code> 或 <code>set</code> 键，则会产生一个异常。</p>
<p>了解到这里已经够我们去理解Vue2.x的响应式原理了。</p>
<p>我们再填一下上面的坑：</p>
<p>如果对象中不存在指定的属性，<code>Object.defineProperty()</code> 会创建这个属性。当描述符中省略某些字段时，这些字段将使用它们的默认值。 搬一下MDN的代码：</p>
<pre><code class="language-javascript">var o = {}; // 创建一个新对象

// 在对象中添加一个属性与数据描述符的示例
Object.defineProperty(o, &quot;a&quot;, {
  value : 37,
  writable : true,
  enumerable : true,
  configurable : true
});

// 对象 o 拥有了属性 a，值为 37

// 在对象中添加一个设置了存取描述符属性的示例
var bValue = 38;
Object.defineProperty(o, &quot;b&quot;, {
  // 使用了方法名称缩写（ES2015 特性）
  // 下面两个缩写等价于：
  // get : function() { return bValue; },
  // set : function(newValue) { bValue = newValue; },
  get() { return bValue; },
  set(newValue) { bValue = newValue; },
  enumerable : true,
  configurable : true
});

o.b; // 38
// 对象 o 拥有了属性 b，值为 38
// 现在，除非重新定义 o.b，o.b 的值总是与 bValue 相同

// 数据描述符和存取描述符不能混合使用
Object.defineProperty(o, &quot;conflict&quot;, {
  value: 0x9f91102,
  get() { return 0xdeadbeef; }
});
// 抛出错误 TypeError: value appears only in data descriptors, get appears only in accessor descriptors
</code></pre>
<h2 id="响应式原理"><a class="header" href="#响应式原理">响应式原理</a></h2>
<p>所谓响应式，即，一个值变化的时候要根据这个变化，产生相应的行为。</p>
<p>在浏览器上，dom渲染完成之后，那么如果你不主动通过dom修改操作来重新渲染，那么这个dom就永远不变了。
那如果dom上渲染的是X的值，X变了怎么办呢。难不成你每次给X赋值的时候，都手动document.balabala吗？</p>
<p>看过上面的set属性之后你可能就想明白了，重点再复习一下：</p>
<p><strong>当属性值被修改时，会调用此函数。</strong></p>
<p>锵锵锵，简单来说就是用<code>get</code>和<code>set</code>来实现的啦。</p>
<h3 id="简单实现"><a class="header" href="#简单实现">简单实现</a></h3>
<p>话不多说，直接上代码 。</p>
<pre><code class="language-javascript">let x;

let f = function (v) {
  return v * 100;
}

// 变化之后的处理函数
let active;

const onXChange = (cb) =&gt; {
  active = cb;
  // 初始化的时候就需要执行一次
  active()
}

// 工厂
const ref = (value) =&gt; {
  let initValue = value;
  return Object.defineProperty({}, &quot;value&quot;, {
    get() {
      return initValue;
    },
    set(newVal) {
      initValue = newVal;
      active();
    }
  })
}

// 初始化
x = ref(1);

// 添加回调
onXChange(() =&gt; {
  console.log(f(x.value));
})

x.value = 2;
x.value = 3;
</code></pre>
<p>上述的写法有点问题。如果，不光是一个callback，有多个callback如何处理？</p>
<p>一个active不够用。所以我们需要一个地方进行依赖收集。（即，多个组件依赖这个数据，每个组件都需要进行变化。）</p>
<h3 id="带依赖收集"><a class="header" href="#带依赖收集">带依赖收集</a></h3>
<p>变化后的代码如下：</p>
<pre><code class="language-javascript">/* eslint-disable no-debugger */
let x;

let f = function (v) {
  return v * 100;
}

let active;

const onXChange = (cb) =&gt; {
  active = cb;
  active();
  active = null;
}
class Dep {
  deps = new Set();
  depend() {
    if (active) {
      this.deps.add(active);
    }
  }
  notify() {
    this.deps.forEach(dep =&gt; dep());
  }
}

const ref = (value) =&gt; {
  let initValue = value;
  let deps = new Dep();

  return Object.defineProperty({}, &quot;value&quot;, {
    get() {
      deps.depend();
      return initValue;
    },
    set(newVal) {
      initValue = newVal;
      deps.notify();
    }
  })
}

x = ref(1);

onXChange(() =&gt; {
  console.log(f(x.value));
})

onXChange(() =&gt; {
  console.log(x.value + 1);
})

x.value = 2;
x.value = 3;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="异步更新队列"><a class="header" href="#异步更新队列">异步更新队列</a></h1>
<p>在上面Vue2.x响应式原理的代码里还是有点问题的。</p>
<p>先捞一遍代码：</p>
<pre><code class="language-javascript">let x;

let f = function (v) {
  return v * 100;
}

let active;

const onXChange = (cb) =&gt; {
  active = cb;
  active();
  active = null;
}
class Dep {
  deps = new Set();
  depend() {
    if (active) {
      this.deps.add(active);
    }
  }
  notify() {
    this.deps.forEach(dep =&gt; dep());
  }
}

const ref = (value) =&gt; {
  let initValue = value;
  let deps = new Dep();

  return Object.defineProperty({}, &quot;value&quot;, {
    get() {
      deps.depend();
      return initValue;
    },
    set(newVal) {
      initValue = newVal;
      deps.notify();
    }
  })
}

x = ref(1);

onXChange(() =&gt; {
  console.log(f(x.value));
})

x.value = 2;
x.value = 3;
</code></pre>
<h2 id="依赖多个变量的情况下的性能问题"><a class="header" href="#依赖多个变量的情况下的性能问题">依赖多个变量的情况下的性能问题</a></h2>
<p>简单删减一波，然后让模板依赖于三个变量：</p>
<pre><code class="language-javascript">let active;

const watch = (cb) =&gt; {
  active = cb;
  active();
  active = null;
}
class Dep {
  deps = new Set();
  depend() {
    if (active) {
      this.deps.add(active);
    }
  }
  notify() {
    this.deps.forEach(dep =&gt; dep());
  }
}

const ref = (value) =&gt; {
  let initValue = value;
  let deps = new Dep();

  return Object.defineProperty({}, &quot;value&quot;, {
    get() {
      deps.depend();
      return initValue;
    },
    set(newVal) {
      initValue = newVal;
      deps.notify();
    }
  })
}

let x = ref(1);
let y = ref(2);
let z = ref(3)

watch(() =&gt; {
  let str = `${x.value} --- ${y.value} --- ${z.value}`
  document.write(str);
  console.log(str)
})

x.value = 2;
y.value = 3;
z.value = 3;
</code></pre>
<p>打开控制台你会发现，每一次值变化的时候，都会触发一次<code>onXChange</code>。</p>
<p>那么问题来了。如果在一个函数中，修改了多个变量，那岂不是页面就要进行多次渲染吗？那么性能肯定下降了。</p>
<p>那么这怎么办呢。</p>
<h2 id="异步更新队列-1"><a class="header" href="#异步更新队列-1">异步更新队列</a></h2>
<p>那么就得用到异步更新队列了。</p>
<p>我们知道JavaScript有宏任务和微任务。所有的微任务都是在宏任务执行完成之后再执行的。</p>
<p>那么我们可以定义一个<code>nextTick</code>函数，用来在宏任务执行完成之后执行微任务。 即，在所有的赋值完成之后，再执行<code>onChange</code>方法。</p>
<pre><code class="language-javascript">const netxtTick = cb =&gt; Promise.resolve().then(cb);
</code></pre>
<p>我们还需要一个队列用来保证先进来的<code>onChange</code>先执行：</p>
<pre><code class="language-javascript">let queue = [];
// 增加任务的方法
let queueJob = job =&gt; {
  // 如果任务已经被添加过，则不添加了
  if (!queue.includes(job)) {
    queue.push(job);
    // 在微任务中执行所有回调
    nextTick(flushJobs);
  }
}
// 执行任务的方法
let flushJobs = () =&gt; {
  let job;
  // 如果队列中第一个始终有任务，则取出来执行
  while ((job = queue.shift()) !== undefined) {
    job();
  }
}
</code></pre>
<p>整体代码如下：</p>
<pre><code class="language-javascript">let active;

const watch = (cb) =&gt; {
  active = cb;
  active();
  active = null;
}

let nextTick = cb =&gt; Promise.resolve().then(cb)

let queue = [];
let queueJob = job =&gt; {
  if (!queue.includes(job)) {
    queue.push(job);
    nextTick(flushJobs);
  }
}
let flushJobs = () =&gt; {
  let job;
  while ((job = queue.shift()) !== undefined) {
    job();
  }
}
class Dep {
  deps = new Set();
  depend() {
    if (active) {
      this.deps.add(active);
    }
  }
  notify() {
    // 注意notify内部变更了
    this.deps.forEach(dep =&gt; queueJob(dep));
  }
}

const ref = (value) =&gt; {
  let initValue = value;
  let deps = new Dep();

  return Object.defineProperty({}, &quot;value&quot;, {
    get() {
      deps.depend();
      return initValue;
    },
    set(newVal) {
      initValue = newVal;
      deps.notify();
    }
  })
}

let x = ref(1);
let y = ref(2);
let z = ref(3)

watch(() =&gt; {
  let str = `${x.value} --- ${y.value} --- ${z.value}`
  document.write(str);
  console.log(str)
})

x.value = 2;
y.value = 3;
z.value = 3;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="computedwatchwatcheffect"><a class="header" href="#computedwatchwatcheffect">computed,watch,watchEffect</a></h1>
<p>今天来实现一下vue里的computed，watch和watchEffect函数。</p>
<p>先把前面的代码简单捞出来，做一些修改。</p>
<p>使得页面上有个按钮，点击按钮，count增加。（万物始于计数器）</p>
<pre><code class="language-javascript">let active;

const watchEffect = (cb) =&gt; {
  active = cb;
  active();
  active = null;
}

let nextTick = cb =&gt; Promise.resolve().then(cb)

let queue = [];
let queueJob = job =&gt; {
  if (!queue.includes(job)) {
    queue.push(job);
    nextTick(flushJobs);
  }
}
let flushJobs = () =&gt; {
  let job;
  while ((job = queue.shift()) !== undefined) {
    job();
  }
}
class Dep {
  deps = new Set();
  depend() {
    if (active) {
      this.deps.add(active);
    }
  }
  notify() {
    this.deps.forEach(dep =&gt; queueJob(dep));
  }
}

const ref = (value) =&gt; {
  let initValue = value;
  let deps = new Dep();

  return Object.defineProperty({}, &quot;value&quot;, {
    get() {
      deps.depend();
      return initValue;
    },
    set(newVal) {
      initValue = newVal;
      deps.notify();
    }
  })
}

let count = ref(0);

document.getElementById('add').addEventListener('click', () =&gt; {
  count.value++;
})

watchEffect(() =&gt; {
  let str = `count is: ${count.value}`;
  document.getElementById('app').innerText = str;
})
</code></pre>
<h2 id="watcheffect"><a class="header" href="#watcheffect">watchEffect</a></h2>
<p>watchEffect是一个函数，接受一个函数。函数内部依赖的值变了，函数就会立即执行。就跟我们之前的watch一模一样。所以，直接给他改个名就行了。</p>
<p>但是还要返回一个stop，用来停止监听，这个最后再说。</p>
<h2 id="computed"><a class="header" href="#computed">computed</a></h2>
<p>computed接受一个函数，内部依赖某个值，并返回一个新的值。内部还有一个缓存。当依赖的值变化的时候才会重新求值。</p>
<h3 id="简单实现-1"><a class="header" href="#简单实现-1">简单实现</a></h3>
<p>简单实现一个computed函数：</p>
<pre><code class="language-javascript">let computed = (fn) =&gt; {
  // 使用闭包来保存一个value
  let value;

  return {
    get value() {
      // 在get中响应式监听，直接在get中执行一次fn即可获取到计算后的值。
      value = fn();
      return value;
    }
  }
}
</code></pre>
<p>上述代码已经可以简单的实现一个计算属性。</p>
<h3 id="缓存功能"><a class="header" href="#缓存功能">缓存功能</a></h3>
<p>但是我们的computed是有缓存的，而且如果多处调用计算属性，那么将会进行多次计算。为了减少计算。我们也要使用缓存。</p>
<p>通过下面的代码可以发现问题：</p>
<pre><code class="language-javascript">let active;

const watchEffect = (cb) =&gt; {
  active = cb;
  active();
  active = null;
}

let nextTick = cb =&gt; Promise.resolve().then(cb)

let queue = [];
let queueJob = job =&gt; {
  if (!queue.includes(job)) {
    queue.push(job);
    nextTick(flushJobs);
  }
}
let flushJobs = () =&gt; {
  let job;
  while ((job = queue.shift()) !== undefined) {
    job();
  }
}
class Dep {
  deps = new Set();
  depend() {
    if (active) {
      this.deps.add(active);
    }
  }
  notify() {
    this.deps.forEach(dep =&gt; queueJob(dep));
  }
}

const ref = (value) =&gt; {
  let initValue = value;
  let deps = new Dep();

  return Object.defineProperty({}, &quot;value&quot;, {
    get() {
      deps.depend();
      return initValue;
    },
    set(newVal) {
      initValue = newVal;
      deps.notify();
    }
  })
}

let computedCount = 0;
let computed = (fn) =&gt; {
  // 使用闭包来保存一个value
  let value;

  return {
    get value() {
      // 在get中响应式监听，直接在get中执行一次fn即可。
      value = fn();
      computedCount += 1;
      return value;
    }
  }
}

let count = ref(0);

let computeCount = computed(() =&gt; count.value + 1)

document.getElementById('add').addEventListener('click', () =&gt; {
  count.value++;
})

watchEffect(() =&gt; {
  let str = `count is: ${count.value} \n computeCount is: ${computeCount.value} \n computedCount: ${computedCount}`;
  document.getElementById('app1').innerText = str;
})

watchEffect(() =&gt; {
  document.getElementById('app2').innerText = `computeCount 2 is : ${computeCount.value} \n computedCount: ${computedCount}`
})
</code></pre>
<p>我们在computed中增加一个flag来控制是否进行计算。</p>
<pre><code class="language-javascript">let computed = (fn) =&gt; {
  // 使用闭包来保存一个value
  let value;
  let dirty = true;

  return {
    get value() {
      // 如果值没有发生变化，返回缓存中的值。
      // 也可以保证多处依赖的时候不会重复计算。
      if (dirty) {
        // 在get中响应式监听，直接在get中执行一次fn即可。
        value = fn();
        computedCount += 1;
        // 置为false
        dirty = false;
      }
      return value;
    }
  }
}
</code></pre>
<p>那么问题来了，既然置为了false，那么何时何地再置为true呢。</p>
<p>显然，在我们触发了set操作。在赋值过后的广播行为里，将所有computed属性里的flag都置为true。</p>
<p>对此需要进行一些改造。</p>
<blockquote>
<p>此刻之前的代码，ref中，<code>initialValue</code>和<code>value</code>的定义不符合语义化，已更改。</p>
</blockquote>
<pre><code class="language-javascript">let active;

let effect = (fn, options = {}) =&gt; {
  // 定义一个effectInner来对active进行赋值和执行的操作。
  let effectInner = (...args) =&gt; {
    try {
      // 常规执行，将自身赋值给active，以在收集依赖的时候调用。
      active = effectInner;
      // 直接执行fn，防止递归调用。然后返回。
      // return active(...args);
      return fn(...args);
    } finally {
      // 为了能最终将active值为空。使用try catch finally的特性。
      active = null;
    }
  }
  // 给effectInner上绑定一个options对象。以在广播的时候调用。
  effectInner.options = options;

  return effectInner;
}

const watchEffect = (cb) =&gt; {
  // 替换为effect
  let runner = effect(cb);
  runner();
}

let nextTick = cb =&gt; Promise.resolve().then(cb)

let queue = [];
let queueJob = job =&gt; {
  if (!queue.includes(job)) {
    queue.push(job);
    nextTick(flushJobs);
  }
}
let flushJobs = () =&gt; {
  let job;
  while ((job = queue.shift()) !== undefined) {
    job();
  }
}
class Dep {
  deps = new Set();
  depend() {
    if (active) {
      this.deps.add(active);
    }
  }
  notify() {
    this.deps.forEach(dep =&gt; {
      queueJob(dep);
      dep.options &amp;&amp; dep.options.schedular &amp;&amp; dep.options.schedular();
    });
    // 放上面好像也没啥事情，丢里面也能跑。不知道为啥课上写外面，也没说为啥。
    // this.deps.forEach(dep =&gt; {
    //   dep.options &amp;&amp; dep.options.schedular &amp;&amp; dep.options.schedular();
    // })
  }
}

const ref = (initValue) =&gt; {
  let value = initValue;
  let deps = new Dep();

  return Object.defineProperty({}, &quot;value&quot;, {
    get() {
      deps.depend();
      return value;
    },
    set(newVal) {
      value = newVal;
      deps.notify();
    }
  })
}

let computedCount = 0;
let computed = (fn) =&gt; {
  // 使用闭包来保存一个value
  let value;
  let dirty = true;
  // 使用effect包裹fn，增加option，以保证在执行完之后。能在广播中调用options里的schedular。
  let runner = effect(fn, {
    // 
    schedular: () =&gt; {
      // 执行这步的时候说明所依赖的值已经更新过了。所以需要置为true保证下面能计算。
      !dirty &amp;&amp; (dirty = true);
    }
  });

  return {
    get value() {
      // 如果值没有发生变化，返回缓存中的值。
      // 也可以保证多处依赖的时候不会重复计算。
      if (dirty) {
        // 在get中响应式监听，直接在get中执行一次fn即可。
        value = runner();
        computedCount += 1;
        dirty = false;
      }
      return value;
    }
  }
}

let count = ref(0);

let computeCount = computed(() =&gt; count.value + 1)

document.getElementById('add').addEventListener('click', () =&gt; {
  count.value++;
})

watchEffect(() =&gt; {
  let str = `count is: ${count.value} \n computeCount is: ${computeCount.value} \n computedCount: ${computedCount}`;
  document.getElementById('app1').innerText = str;
})

watchEffect(() =&gt; {
  document.getElementById('app2').innerText = `computeCount 2 is : ${computeCount.value} \n computedCount: ${computedCount}`
})
</code></pre>
<p>细心的小伙伴发现了。点击add的时候下面的<code>id=app2</code>的<code>dom</code>不刷新了。这是为啥呢。</p>
<p>我们知道<code>watchEffect</code>会立即执行一遍。所以一开始的时候。我们的值是<code>computeCount.value</code>是1，没毛病。并且在设置缓存之后，<code>computedCount</code>也是1了。并没有重复计算。因为在执行<code>app2</code>的<code>dom</code>的渲染的时候，<code>count</code>的值并没有刷新，所以直接从缓存中取的值。所以上述代码的缓存功能是实现了。</p>
<p>至于为啥不更新。因为<code>app2</code>并不依赖于count的值，所以在依赖收集的时候，并没有被增加到<code>deps</code>里去。在页面渲染完毕之后，<code>deps</code>里只有两个<code>dep</code>，都是<code>app1</code>在渲染的时候产生的。一个是直接调用<code>get cout.value</code>的时候产生的依赖，还有一个是调用<code>computed</code>里的<code>count.value + 1</code>的时候使用的<code>get</code>产生的依赖。所以<code>count</code>更新的时候只会执行这两个。并不会触发<code>app2</code>的更新。</p>
<p>没搞懂的。理清一下逻辑。在<code>notify</code>的时候打个断点。在<code>depend</code>的时候打一个断点。就跑懂啦。</p>
<h2 id="watch"><a class="header" href="#watch">watch</a></h2>
<p>监听变化，并在监听回调函数中返回数据变更前后的两个值，常用于在数据变化之后执行的异步操作或者开销交大的操作。</p>
<p>那么，<code>app2</code>的不渲染问题也可以在这里解决。（不直接依赖<code>count</code>，但是需要根据<code>count</code>的变化而变化）</p>
<p>那么，核心思想就是，触发<code>count</code>的<code>get</code>方法把执行的回调函数增加到<code>deps</code>里。</p>
<p>我们这里watch的第一个参数只给到<code>function</code>，其他类型的不讨论。</p>
<p>所以有一个getter：</p>
<pre><code class="language-javascript">// source是一个函数，里面有所依赖（要监听）的值
let getter = () =&gt; {
  return source();
};
</code></pre>
<p>然后我们需要一个增加依赖的地方，所以用到了effect，然后还需要给回调函数准备<code>newVal</code>和<code>oldVal</code>：</p>
<pre><code class="language-js">let oldVal;
const runner = effect(getter, {
  schedular: () =&gt; {
    // 重复触发依赖收集
    let newVal = runner();
    // 只有当newVal不等于oldVal的时候才触发，即有变化之后才触发
    if (newVal !== oldVal) {
      cb(newVal, oldVal);
      // 重新赋值oldVal
      oldVal = newVal;
    }
  }
})
// 初始化赋值oldVal
oldVal = runner();
</code></pre>
<p>然后我们去使用watch，并且在callback里不直接使用<code>cout.value</code>，完整代码如下：</p>
<pre><code class="language-js">let active;

let effect = (fn, options = {}) =&gt; {
  let effectInner = (...args) =&gt; {
    try {
      active = effectInner;
      return fn(...args);
    } finally {
      active = null;
    }
  }
  effectInner.options = options;

  return effectInner;
}

const watchEffect = (cb) =&gt; {
  let runner = effect(cb);
  runner();
}

let nextTick = cb =&gt; Promise.resolve().then(cb)

let queue = [];
let queueJob = job =&gt; {
  if (!queue.includes(job)) {
    queue.push(job);
    nextTick(flushJobs);
  }
}
let flushJobs = () =&gt; {
  let job;
  while ((job = queue.shift()) !== undefined) {
    job();
  }
}
class Dep {
  deps = new Set();
  depend() {
    if (active) {
      this.deps.add(active);
    }
  }
  notify() {
    this.deps.forEach(dep =&gt; {
      queueJob(dep);
      dep.options &amp;&amp; dep.options.schedular &amp;&amp; dep.options.schedular();
    });
    // this.deps.forEach(dep =&gt; {
    //   dep.options &amp;&amp; dep.options.schedular &amp;&amp; dep.options.schedular();
    // })
  }
}

const ref = (initValue) =&gt; {
  let value = initValue;
  let deps = new Dep();

  return Object.defineProperty({}, &quot;value&quot;, {
    get() {
      deps.depend();
      return value;
    },
    set(newVal) {
      value = newVal;
      deps.notify();
    }
  })
}

let computed = (fn) =&gt; {
  // 使用闭包来保存一个value
  let value;
  let dirty = true;
  let runner = effect(fn, {
    schedular: () =&gt; {
      !dirty &amp;&amp; (dirty = true);
    }
  });

  return {
    get value() {
      // 如果值没有发生变化，返回缓存中的值。
      // 也可以保证多处依赖的时候不会重复计算。
      if (dirty) {
        // 在get中响应式监听，直接在get中执行一次fn即可。
        value = runner();
        dirty = false;
      }
      return value;
    }
  }
}

let watch = (source, cb) =&gt; {
  let getter = () =&gt; {
    return source();
  };
  let oldVal;
  const runner = effect(getter, {
    schedular: () =&gt; {
      // 重复触发依赖收集
      let newVal = runner();
      if (newVal !== oldVal) {
        cb(newVal, oldVal);
        oldVal = newVal;
      }
    }
  })

  oldVal = runner();
}

let count = ref(0);

let computeCount = computed(() =&gt; count.value + 1)

watch(
  () =&gt; count.value,
  (newVal, preVal) =&gt; {
    console.log(newVal, preVal);
    document.getElementById('app2').innerText = `watchCount is : ${newVal}`
  }
)

document.getElementById('add').addEventListener('click', () =&gt; {
  count.value++;
})

watchEffect(() =&gt; {
  let str = `count is: ${count.value} \n computeCount is: ${computeCount.value}`;
  document.getElementById('app1').innerText = str;
})

// watchEffect(() =&gt; {
//   document.getElementById('app2').innerText = `computeCount 2 is : ${computeCount.value}`
// })
</code></pre>
<p>可以看到<code>app2</code>已经被更新了。</p>
<p>但是首次渲染的时候没有显示。当然咯。首次渲染的时候<code>count.value</code>又没变化咯。</p>
<p>要是我就是要初始化的时候也渲染呢？</p>
<p>那么就到了watch的options里，有个叫immediate的参数。用来判断是否需要立即执行一次。</p>
<p>对watch进行一下小修改：</p>
<pre><code class="language-js">let watch = (source, cb, options = { immediate: false }) =&gt; {
  const { immediate } = options;
  let getter = () =&gt; {
    return source();
  };
  let oldVal;

  const applyCb = () =&gt; {
    // 重复触发依赖收集
    let newVal = runner();
    if (newVal !== oldVal) {
      cb(newVal, oldVal);
      oldVal = newVal;
    }
  }
  const runner = effect(getter, {
    // schedular: () =&gt; applyCb()
    schedular: applyCb
  })

  if (immediate) {
    applyCb();
  } else {
    oldVal = runner();
  }
}
</code></pre>
<p>这样的话第一次进来就可以看到啦。</p>
<div style="break-before: page; page-break-before: always;"></div><p>先把之前写过的vue的响应式原理里的代码略加修改搬过来</p>
<pre><code class="language-javascript">/* eslint-disable no-unused-vars */
// let x;
// let y;
// let f = n =&gt; n * 100 + 100;

let active;

let watch = function (cb) {
  active = cb;
  active();
  active = null;
};

let queue = [];
let nextTick = cb =&gt; Promise.resolve().then(cb);
let queueJob = job =&gt; {
  if (!queue.includes(job)) {
    queue.push(job);
    nextTick(flushJobs);
  }
};
let flushJobs = () =&gt; {
  let job;
  while ((job = queue.shift()) !== undefined) {
    job();
  }
};

class Dep {
  constructor() {
    this.deps = new Set();
  }
  depend() {
    if (active) {
      this.deps.add(active);
    }
  }
  notify() {
    this.deps.forEach(dep =&gt; queueJob(dep));
  }
}

let ref = initValue =&gt; {
  let value = initValue;
  let dep = new Dep();

  return Object.defineProperty({}, &quot;value&quot;, {
    get() {
      dep.depend();
      return value;
    },
    set(newValue) {
      value = newValue;
      dep.notify();
    }
  });
};

let createReactive = (target, prop, value) =&gt; {
  let dep = new Dep();

  // return new Proxy(target, {
  //   get(target, prop) {
  //     dep.depend();
  //     return Reflect.get(target, prop);
  //   },
  //   set(target, prop, value) {
  //     Reflect.set(target, prop, value);
  //     dep.notify();
  //   },
  // });

  return Object.defineProperty(target, prop, {
    get() {
      dep.depend();
      return value;
    },
    set(newValue) {
      value = newValue;
      dep.notify();
    }
  });
};

export let reactive = obj =&gt; {
  let dep = new Dep();

  Object.keys(obj).forEach(key =&gt; {
    let value = obj[key];
    createReactive(obj, key, value);
  });

  return obj;
};

// let data = reacitve({
//   count: 0
// });

import { Store } from &quot;./vuex&quot;;

let store = new Store({
  state: {
    count: 0
  },
  mutations: {
    addCount(state, payload) {
      state.count += payload || 1;
    }
  },
  plugins: [
    store =&gt;
      store.subscribe((mutation, state) =&gt; {
        console.log(mutation);
      })
  ]
});

document.getElementById(&quot;add&quot;).addEventListener(&quot;click&quot;, function () {
  // data.count++;
  store.commit(&quot;addCount&quot;, 1);
});
let str;
watch(() =&gt; {
  str = `hello ${store.state.count}`;
  document.getElementById(&quot;app&quot;).innerText = str;
});
</code></pre>
<p>vuex其实也就是在构造过程中调用了vue的reactive来包裹自己的state来使得state变为响应式的。</p>
<pre><code class="language-javascript">import { reactive } from './myVue';

export class Store {

  constructor(options = {}) {
    let { state, mutations, plugins } = options;
    this._vm = reactive(state);
    this._mutations = mutations;

    this._subscribe = [];
    plugins.forEach(plugin =&gt; plugin(this));
  }

  get state() {
    return this._vm;
  }

  commit(type, payload) {
    const entry = this._mutations[type];
    if (!entry) {
      return;
    }
    entry(this.state, payload);
    this._subscribe.forEach(fn =&gt; fn({ type, payload }, this.state));
  }

  subscribe(fn) {
    if (!this._subscribe.includes(fn)) {
      this._subscribe.push(fn);
    }
  }

}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="http20"><a class="header" href="#http20">HTTP2.0</a></h2>
<ul>
<li>
<p>多路复用</p>
</li>
<li>
<p>防止队头阻塞</p>
</li>
<li>
<p>压缩HTTP头部</p>
</li>
<li>
<p>服务端推送</p>
</li>
<li>
<p>二进制分帧</p>
</li>
</ul>
<h2 id="前言"><a class="header" href="#前言">前言</a></h2>
<p>HTTP2.0大幅度的提高了web性能，在HTTP1.1完全语义兼容的基础上，进一步减少了网络的延迟。实现低延迟高吞吐量。对于前端开发者而言，减少了优化工作。本文将重点围绕以下几点新特性的作用、工作过程以及如何更出色的完成了优化工作来介绍HTTP2.0</p>
<ul>
<li>二进制分帧</li>
<li>首部压缩</li>
<li>多路复用</li>
<li>请求优先级</li>
<li>服务器推送</li>
</ul>
<h2 id="一-介绍"><a class="header" href="#一-介绍">一. 介绍</a></h2>
<p>HTTP/2是HTTP协议自1999年HTTP1.1发布后的首个更新，主要基于SPDY协议。</p>
<h4 id="11-什么是spdy协议"><a class="header" href="#11-什么是spdy协议">1.1 什么是SPDY协议</a></h4>
<p>SPDY是Speedy的昵音，意为“更快”。它是Google开发的基于TCP协议的应用层协议。目标是优化HTTP协议的性能，通过压缩、多路复用和优先级等技术，缩短网页的加载时间并提高安全性。SPDY协议的核心思想是尽量减少TCP连接数。SPDY并不是一种用于替代HTTP的协议，而是对HTTP协议的增强。</p>
<h4 id="12-http1x的缺点"><a class="header" href="#12-http1x的缺点">1.2 HTTP1.X的缺点</a></h4>
<p>任何事物的更新都是为了弥补或修复上个版本的某些问题，那么我们来看看HTTP1.x都有哪些缺点以至于我们要使用HTTP2.0。</p>
<p>HTTP1.x有以下几个主要缺点：</p>
<ol>
<li>HTTP/1.0一次只允许在一个TCP连接上发起一个请求，HTTP/1.1使用的流水线技术也只能部分处理请求并发，仍然会存在队列头阻塞问题，因此客户端在需要发起多次请求时，通常会采用建立多连接来减少延迟。</li>
<li>单向请求，只能由客户端发起。</li>
<li>请求报文与响应报文首部信息冗余量大。</li>
<li>数据未压缩，导致数据的传输量大</li>
</ol>
<p>我们可以通过一个链接来对比一下HTTP2.0到底比HTTP1.x快了多少。<a href="https://http2.akamai.com/demo">链接地址</a></p>
<h2 id="二-二进制分帧"><a class="header" href="#二-二进制分帧">二. 二进制分帧</a></h2>
<p>在不改变HTTP1.x的语义、方法、状态码、URL以及首部字段的情况下，HTTP2.0是怎样突破HTTP1.1的性能限制，改进传输性能，实现低延迟高吞吐量的呢？关键之一就是在应用层（HTTP）和传输层（TCP）之间增加一个二进制分帧层。</p>
<p>在整理二进制分帧及其作用的时候我们先来铺垫一点关于帧的知识：</p>
<ul>
<li>帧：HTTP2.0通信的最小单位，所有帧都共享一个8字节的首部，其中包含帧的长度、类型、标志、还有一个保留位，并且至少有标识出当前帧所属的流的标识符，帧承载着特定类型的数据，如HTTP首部、负荷、等等。</li>
<li>消息：比帧大的通讯单位，是指逻辑上的HTTP消息，比如请求、响应等。由一个或多个帧组成</li>
<li>流：比消息大的通讯单位。是TCP连接中的一个虚拟通道，可以承载双向的消息。每个流都有一个唯一的整数标识符</li>
</ul>
<p>HTTP2.0中所有加强性能的核心是二进制传输，在HTTP1.x中，我们是通过文本的方式传输数据。基于文本的方式传输数据存在很多缺陷，文本的表现形式有多样性，因此要做到健壮性考虑的场景必然有很多，但是二进制则不同，只有0和1的组合，因此选择了二进制传输，实现方便且健壮。
在HTTP2.0中引入了新的编码机制，所有传输的数据都会被分割，并采用二进制格式编码。 <img src="Network/./images/20190802162333949.png" alt="在这里插入图片描述" /></p>
<p>为了保证HTTP不受影响，那就需要在应用层（HTTP2.0）和传输层（TCP or
UDP）之间增加一个二进制分帧层。<code>在二进制分帧层上，HTTP2.0会将所有传输的信息分为更小的消息和帧，并采用二进制格式编码，其中HTTP1.x的首部信息会被封装到Headers帧，而Request Body则封装到Data帧。</code></p>
<h2 id="三-首部压缩"><a class="header" href="#三-首部压缩">三. 首部压缩</a></h2>
<p>HTTP1.1并不支持HTTP首部压缩，为此SPDY和HTTP2.0出现了。SPDY是用的是DEFLATE算法，而HTTP2.0则使用了专门为首部压缩设计的HPACK算法。</p>
<p>HTTP每次通讯（请求或响应）都会携带首部信息用于描述资源属性。</p>
<p>在HTTP1.0中，我们使用文本的形式传输header，在header中携带cookie的话，每次都需要重复传输几百到几千的字节，这着实是一笔不小的开销。</p>
<p>在HTTP2.0中，我们使用了HPACK（HTTP2头部压缩算法）压缩格式对传输的header进行编码，减少了header的大小。并在两端维护了索引表，用于记录出现过的header，后面在传输过程中就可以传输已经记录过的header的键名，对端收到数据后就可以通过键名找到对应的值。</p>
<h2 id="四-多路复用"><a class="header" href="#四-多路复用">四. 多路复用</a></h2>
<p>在HTTP1.x中，我们经常会使用到雪碧图、使用多个域名等方式来进行优化，都是因为浏览器限制了同一个域名下的请求数量，当页面需要请求很多资源的时候，队头阻塞（Head of line
blocking）会导致在达到最大请求时，资源需要等待其他资源请求完成后才能继续发送。</p>
<p>HTTP2.0中,基于二进制分帧层，HTTP2.0可以在共享TCP连接的基础上同时发送请求和响应。HTTP消息被分解为独立的帧，而不破坏消息本身的语义，交错发出去，在另一端根据流标识符和首部将他们重新组装起来。
通过该技术，可以避免HTTP旧版本的队头阻塞问题，极大提高传输性能。</p>
<h2 id="五-请求优先级"><a class="header" href="#五-请求优先级">五. 请求优先级</a></h2>
<p>把HTTP消息分为很多独立帧之后，就可以通过优化这些帧的交错和传输顺序进一步优化性能。</p>
<h2 id="六-服务器推送"><a class="header" href="#六-服务器推送">六. 服务器推送</a></h2>
<p>HTTP2.0新增的一个强大的新功能，就是服务器可以对一个客户端请求发送多个响应。服务器向客户端推送资源无需客户端明确的请求。</p>
<p>服务端根据客户端的请求，提前返回多个响应，推送额外的资源给客户端。如下图，客户端请求stream 1(/page.html)。服务端在返回stream 1的消息的同时推送了stream
2(/script.js)和stream 4(/style.css) <img src="Network/./images/20190802165438943.jpg" alt="在这里插入图片描述" />
服务端推送是一种在客户端请求之前发送数据的机制。在HTTP2.0中，服务器可以对一个客户端的请求发送多个响应。如果一个请求是由你的主页发送的，服务器可能会响应主页内容、logo以及样式表，因为他知道客户端会用到这些东西。这样不但减轻了数据传送冗余步骤，也加快了页面响应的速度，提高了用户体验。</p>
<p>推送的缺点：所有推送的资源都必须遵守同源策略。换句话说，服务器不能随便将第三方资源推送给客户端，而必须是经过双方的确认才行。</p>
<p><a href="https://blog.csdn.net/yexudengzhidao/article/details/98207149">摘自</a></p>
<h2 id="http30"><a class="header" href="#http30">HTTP3.0</a></h2>
<p>把TCP层拆成QUIC + UDP</p>
<p><img src="Network/./images/image-20210624165958643.png" alt="image-20210624165958643" /></p>
<h3 id="http20-1"><a class="header" href="#http20-1">HTTP2.0</a></h3>
<h4 id="11-http20和tcp的爱恨纠葛"><a class="header" href="#11-http20和tcp的爱恨纠葛">1.1 HTTP2.0和TCP的爱恨纠葛</a></h4>
<p>HTTP2.0是2015年推出的，还是比较年轻的，其重要的二进制分帧协议、多路复用、头部压缩、服务端推送等重要优化使HTTP协议真正上了一个新台阶。</p>
<p><img src="Network/./images/7acb0a46f21fbe0969e83c0c59894b348644ad60.png" alt="" /></p>
<p>像谷歌这种重要的公司并没有满足于此，而且想继续提升HTTP的性能，花最少的时间和资源获取极致体验。</p>
<p>那么肯定要问HTTP2.0虽然性能已经不错了，还有什么不足吗？</p>
<p>建立连接时间长(本质上是TCP的问题) 队头阻塞问题 移动互联网领域表现不佳(弱网环境) ......</p>
<p>熟悉HTTP2.0协议的同学应该知道，这些缺点基本都是由于TCP协议引起的，水能载舟亦能覆舟，其实TCP也很无辜呀！</p>
<p><img src="Network/./images/1e30e924b899a901cda64a7e2c7c4d7c0008f5d3.png" alt="" /></p>
<p>在我们眼里，TCP是面向连接、可靠的传输层协议，当前几乎所有重要的协议和应用都是基于TCP来实现的。</p>
<p>网络环境的改变速度很快，但是TCP协议相对缓慢，正是这种矛盾促使谷歌做出了一个看似出乎意料的决定-基于UDP来开发新一代HTTP协议。</p>
<h4 id="12-谷歌为什么选择udp"><a class="header" href="#12-谷歌为什么选择udp">1.2 谷歌为什么选择UDP</a></h4>
<p>上文提到，谷歌选择UDP是看似出乎意料的，仔细想一想其实很有道理。</p>
<p>我们单纯地看看TCP协议的不足和UDP的一些优点：</p>
<p>基于TCP开发的设备和协议非常多，兼容困难 TCP协议栈是Linux内部的重要部分，修改和升级成本很大 UDP本身是无连接的、没有建链和拆链成本 UDP的数据包无队头阻塞问题 UDP改造成本小</p>
<p>从上面的对比可以知道，谷歌要想从TCP上进行改造升级绝非易事，但是UDP虽然没有TCP为了保证可靠连接而引发的问题，但是UDP本身不可靠，又不能直接用。</p>
<p><img src="Network/./images/42166d224f4a20a4d6863d33bfbbdf25700ed09e.jpeg" alt="" /></p>
<p>综合而知，谷歌决定在UDP基础上改造一个具备TCP协议优点的新协议也就顺理成章了，这个新协议就是QUIC协议。</p>
<h4 id="13-quic协议和http30"><a class="header" href="#13-quic协议和http30">1.3 QUIC协议和HTTP3.0</a></h4>
<p>QUIC其实是Quick UDP Internet Connections的缩写，直译为快速UDP互联网连接。</p>
<p><img src="Network/./images/b7003af33a87e950295f0a4f3fd11444faf2b4bd.jpeg" alt="" /></p>
<p>我们来看看维基百科对于QUIC协议的一些介绍：</p>
<p>QUIC协议最初由Google的Jim Roskind设计，实施并于2012年部署，在2013年随着实验的扩大而公开宣布，并向IETF进行了描述。</p>
<p>QUIC提高了当前正在使用TCP的面向连接的Web应用程序的性能。它在两个端点之间使用用户数据报协议（UDP）建立多个复用连接来实现此目的。</p>
<p>QUIC的次要目标包括减少连接和传输延迟，在每个方向进行带宽估计以避免拥塞。它还将拥塞控制算法移动到用户空间，而不是内核空间，此外使用前向纠错（FEC）进行扩展，以在出现错误时进一步提高性能。</p>
<p>HTTP3.0又称为HTTP Over QUIC，其弃用TCP协议，改为使用基于UDP协议的QUIC协议来实现。</p>
<p><img src="Network/./images/6a63f6246b600c334d9de0c037a51608dbf9a1c6.jpeg" alt="" /></p>
<h3 id="quic协议详解"><a class="header" href="#quic协议详解">QUIC协议详解</a></h3>
<p>择其善者而从之，其不善者而改之。</p>
<p>HTTP3.0既然选择了QUIC协议，也就意味着HTTP3.0基本继承了HTTP2.0的强大功能，并且进一步解决了HTTP2.0存在的一些问题，同时必然引入了新的问题。</p>
<p><img src="Network/./images/1e30e924b899a901cda64a7e2c7c4d7c0008f5d3-1.png" alt="" /></p>
<p>QUIC协议必须要实现HTTP2.0在TCP协议上的重要功能，同时解决遗留问题，我们来看看QUIC是如何实现的。</p>
<h4 id="21-队头阻塞问题"><a class="header" href="#21-队头阻塞问题">2.1 队头阻塞问题</a></h4>
<p>队头阻塞 Head-of-line blocking（缩写为HOL blocking）是计算机网络中是一种性能受限的现象，通俗来说就是：一个数据包影响了一堆数据包，它不来大家都走不了。</p>
<p>队头阻塞问题可能存在于HTTP层和TCP层，在HTTP1.x时两个层次都存在该问题。</p>
<p><img src="Network/./images/03087bf40ad162d938cfbf693d36eeeb8b13cd97.png" alt="" /></p>
<p>HTTP2.0协议的多路复用机制解决了HTTP层的队头阻塞问题，但是在TCP层仍然存在队头阻塞问题。</p>
<p>TCP协议在收到数据包之后，这部分数据可能是乱序到达的，但是TCP必须将所有数据收集排序整合后给上层使用，如果其中某个包丢失了，就必须等待重传，从而出现某个丢包数据阻塞整个连接的数据使用。</p>
<p>QUIC协议是基于UDP协议实现的，在一条链接上可以有多个流，流与流之间是互不影响的，当一个流出现丢包影响范围非常小，从而解决队头阻塞问题。</p>
<h4 id="22-0rtt-建链"><a class="header" href="#22-0rtt-建链">2.2 0RTT 建链</a></h4>
<p>衡量网络建链的常用指标是RTT Round-Trip Time，也就是数据包一来一回的时间消耗。</p>
<p><img src="Network/./images/4bed2e738bd4b31c9c05217bb73f60789f2ff821.jpeg" alt="" /></p>
<p>RTT包括三部分：往返传播时延、网络设备内排队时延、应用程序数据处理时延。</p>
<p><img src="Network/./images/faf2b2119313b07e2a6f75f9233ed62495dd8c65.jpeg" alt="" /></p>
<p>一般来说HTTPS协议要建立完整链接包括:TCP握手和TLS握手，总计需要至少2-3个RTT，普通的HTTP协议也需要至少1个RTT才可以完成握手。</p>
<p>然而，QUIC协议可以实现在第一个包就可以包含有效的应用数据，从而实现0RTT，但这也是有条件的。</p>
<p><img src="Network/./images/95f5c7e411d0b7f96d182abe284be551.gif" alt="" /></p>
<p>简单来说，基于TCP协议和TLS协议的HTTP2.0在真正发送数据包之前需要花费一些时间来完成握手和加密协商，完成之后才可以真正传输业务数据。</p>
<p>但是QUIC则第一个数据包就可以发业务数据，从而在连接延时有很大优势，可以节约数百毫秒的时间。</p>
<p><img src="Network/./images/9345d688d43f87946df4ec30fdf249f31ad53a91.png" alt="" /></p>
<p>QUIC的0RTT也是需要条件的，对于第一次交互的客户端和服务端0RTT也是做不到的，毕竟双方完全陌生。</p>
<p>因此，QUIC协议可以分为首次连接和非首次连接，两种情况进行讨论。</p>
<h4 id="23-首次连接和非首次连接"><a class="header" href="#23-首次连接和非首次连接">2.3 首次连接和非首次连接</a></h4>
<p>使用QUIC协议的客户端和服务端要使用1RTT进行密钥交换，使用的交换算法是DH(Diffie-Hellman)迪菲-赫尔曼算法。</p>
<p>DH算法开辟了密钥交换的新思路，在之前的文章中提到的RSA算法也是基于这种思想实现的，但是DH算法和RSA的密钥交换不完全一样，感兴趣的读者可以看看DH算法的数学原理。</p>
<p>DH算法开辟了密钥交换的新思路，在之前的文章中提到的RSA算法也是基于这种思想实现的，但是DH算法和RSA的密钥交换不完全一样，感兴趣的读者可以看看DH算法的数学原理。</p>
<h5 id="231-首次连接"><a class="header" href="#231-首次连接">2.3.1 首次连接</a></h5>
<p>简单来说一下，首次连接时客户端和服务端的密钥协商和数据传输过程，其中涉及了DH算法的基本过程：</p>
<ol>
<li>客户端对于首次连接的服务端先发送client hello请求。</li>
<li>服务端生成一个素数p和一个整数g，同时生成一个随机数 (笔误-此处应该是Ks_pri)为私钥，然后计算出公钥 = mod p，服务端将，p，g三个元素打包称为config，后续发送给客户端。</li>
<li>客户端随机生成一个自己的私钥，再从config中读取g和p，计算客户端公钥 = mod p。</li>
<li>客户端使用自己的私钥和服务端发来的config中读取的服务端公钥，生成后续数据加密用的密钥K = mod p。</li>
<li>客户端使用密钥K加密业务数据，并追加自己的公钥，都传递给服务端。</li>
<li>服务端根据自己的私钥和客户端公钥生成客户端加密用的密钥K = mod p。</li>
<li>为了保证数据安全，上述生成的密钥K只会生成使用1次，后续服务端会按照相同的规则生成一套全新的公钥和私钥，并使用这组公私钥生成新的密钥M。</li>
<li>服务端将新公钥和新密钥M加密的数据发给客户端，客户端根据新的服务端公钥和自己原来的私钥计算出本次的密钥M，进行解密。</li>
<li>之后的客户端和服务端数据交互都使用密钥M来完成，密钥K只使用1次。</li>
</ol>
<p><img src="Network/./images/58ee3d6d55fbb2fb89e29f597ca367a34423dca5.png" alt="" /></p>
<h5 id="232-非首次连接"><a class="header" href="#232-非首次连接">2.3.2 非首次连接</a></h5>
<p>前面提到客户端和服务端首次连接时服务端传递了config包，里面包含了服务端公钥和两个随机数，客户端会将config存储下来，后续再连接时可以直接使用，从而跳过这个1RTT，实现0RTT的业务数据交互。</p>
<p>客户端保存config是有时间期限的，在config失效之后仍然需要进行首次连接时的密钥交换。</p>
<h4 id="24-前向安全问题"><a class="header" href="#24-前向安全问题">2.4 前向安全问题</a></h4>
<p>前向安全是密码学领域的专业术语，看下百度上的解释：</p>
<p>前向安全或前向保密Forward Secrecy是密码学中通讯协议的安全属性，指的是长期使用的主密钥泄漏不会导致过去的会话密钥泄漏。</p>
<p>前向安全能够保护过去进行的通讯不受密码或密钥在未来暴露的威胁，如果系统具有前向安全性，就可以保证在主密钥泄露时历史通讯的安全，即使系统遭到主动攻击也是如此。</p>
<p>通俗来说，前向安全指的是密钥泄漏也不会让之前加密的数据被泄漏，影响的只有当前，对之前的数据无影响。</p>
<p>前面提到QUIC协议首次连接时先后生成了两个加密密钥，由于config被客户端存储了，如果期间服务端私钥泄漏，那么可以根据K = mod p计算出密钥K。</p>
<p>如果一直使用这个密钥进行加解密，那么就可以用K解密所有历史消息，因此后续又生成了新密钥，使用其进行加解密，当时完成交互时则销毁，从而实现了前向安全。</p>
<p><img src="Network/./images/6c224f4a20a44623fec5572daecb35090df3d767.png" alt="" /></p>
<h4 id="25-前向纠错"><a class="header" href="#25-前向纠错">2.5 前向纠错</a></h4>
<p>前向纠错是通信领域的术语，看下百科的解释：</p>
<p>前向纠错也叫前向纠错码Forward Error Correction 简称FEC 是增加数据通讯可信度的方法，在单向通讯信道中，一旦错误被发现，其接收器将无权再请求传输。</p>
<p>FEC 是利用数据进行传输冗余信息的方法，当传输中出现错误，将允许接收器再建数据。</p>
<p>听这段描述就是做校验的，看看QUIC协议是如何实现的：</p>
<p>QUIC每发送一组数据就对这组数据进行异或运算，并将结果作为一个FEC包发送出去，接收方收到这一组数据后根据数据包和FEC包即可进行校验和纠错。</p>
<h4 id="26-连接迁移"><a class="header" href="#26-连接迁移">2.6 连接迁移</a></h4>
<p>网络切换几乎无时无刻不在发生。</p>
<p>TCP协议使用五元组来表示一条唯一的连接，当我们从4G环境切换到wifi环境时，手机的IP地址就会发生变化，这时必须创建新的TCP连接才能继续传输数据。</p>
<p>QUIC协议基于UDP实现摒弃了五元组的概念，使用64位的随机数作为连接的ID，并使用该ID表示连接。</p>
<p>基于QUIC协议之下，我们在日常wifi和4G切换时，或者不同基站之间切换都不会重连，从而提高业务层的体验。</p>
<p><img src="Network/./images/42166d224f4a20a4d314257ea2bbdf25730ed075.png" alt="" /></p>
<h3 id="quic的应用和前景"><a class="header" href="#quic的应用和前景">QUIC的应用和前景</a></h3>
<p>通过前面的一些介绍我们看出来QUIC协议虽然是基于UDP来实现的，但是它将TCP的重要功能都进行了实现和优化，否则使用者是不会买账的。</p>
<p>QUIC协议的核心思想是将TCP协议在内核实现的诸如可靠传输、流量控制、拥塞控制等功能转移到用户态来实现，同时在加密传输方向的尝试也推动了TLS1.3的发展。</p>
<p>但是TCP协议的势力过于强大，很多网络设备甚至对于UDP数据包做了很多不友好的策略，进行拦截从而导致成功连接率下降。</p>
<p>主导者谷歌在自家产品做了很多尝试，国内腾讯公司也做了很多关于QUIC协议的尝试。</p>
<p>其中腾讯云对QUIC协议表现了很大的兴趣，并做了一些优化然后在一些重点产品中对连接迁移、QUIC成功率、弱网环境耗时等进行了实验，给出了来自生产环境的诸多宝贵数据。</p>
<p>简单看一组腾讯云在移动互联网场景下的不同丢包率下的请求耗时分布：</p>
<p><img src="Network/./images/3ac79f3df8dcd1009dede5055f620017b8122f94.png" alt="" /></p>
<p>任何新生事物的推动都是需要时间的，出现多年的HTTP2.0和HTTPS协议的普及度都没有预想高，IPv6也是如此，不过QUIC已经展现了强大的生命力，让我们拭目以待吧！</p>
<p><a href="https://baijiahao.baidu.com/s?id=1677802258258817086&amp;wfr=spider&amp;for=pc">摘自</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="git-设置代理"><a class="header" href="#git-设置代理">Git 设置代理</a></h1>
<p>1.设置代理:</p>
<pre><code class="language-shell">git config --global http.proxy http://IP:Port
</code></pre>
<p>2.代理设置完成后，查看设置是否生效：</p>
<pre><code class="language-shell">git config -–get -–global http.proxy
</code></pre>
<p>3.删除代理设置</p>
<pre><code class="language-shell">git config --global --unset http.proxy
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
                        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
                
    </body>
</html>
